СВОДНАЯ ИНФОРМАЦИЯ
Дата создания: Пн 05 янв 2026 06:43:16 MSK
Всего директорий: 11
Всего файлов: 29
Размер итогового документа: 172K
========================================

=== ФАЙЛ: ./P2/TEST.SH ===
Путь: /home/s/Рабочий стол/гит/P2/TEST.SH
Размер: 4,0K
Дата изменения: 2026-01-01 09:39:39.791517002 +0300

СОДЕРЖИМОЕ:
----------------------------------------
local uptime_human uptime_seconds
if [[ -f /proc/uptime ]]; then
    # Читаем сырые данные
    uptime_seconds=$(awk '{printf "%.0f", $1}' /proc/uptime)
    echo "--- ОТЛАДКА 1: Всего секунд аптайма: $uptime_seconds ---"

    local days hours mins
    days=$((uptime_seconds / 86400))
    hours=$(((uptime_seconds % 86400) / 3600))
    mins=$(((uptime_seconds % 3600) / 60))
    
    echo "--- ОТЛАДКА 2: Рассчитано: Дней: $days, Часов: $hours, Минут: $mins ---"

    uptime_human=""
    
    # Сборка дней
    if [[ $days -gt 0 ]]; then
        [[ $days -eq 1 ]] && uptime_human="${days} day" || uptime_human="${days} days"
        uptime_human+=", "
        echo "--- ОТЛАДКА 3: Добавлены дни. Текущая строка: '$uptime_human' ---"
    fi
    
    # Сборка часов
    [[ $hours -eq 1 ]] && uptime_human+="${hours} hour" || uptime_human+="${hours} hours"
    echo "--- ОТЛАДКА 4: Добавлены часы. Текущая строка: '$uptime_human' ---"
    
    uptime_human+=", "
    
    # Сборка минут
    [[ $mins -eq 1 ]] && uptime_human+="${mins} minute" || uptime_human+="${mins} minutes"
    echo "--- ОТЛАДКА 5: Итоговая строка: '$uptime_human' ---"

else
    echo "--- ОТЛАДКА 6: Файл /proc/uptime не найден! ---"
    uptime_seconds="N/A"
    uptime_human="N/A"
fi



# ./TEST.SH: строка 1: local: можно использовать только внутри функции
# --- ОТЛАДКА: Всего секунд аптайма: 44473 ---
# ./TEST.SH: строка 7: local: можно использовать только внутри функции
# --- ОТЛАДКА: Рассчитано: Дней: 0, Часов: 12, Минут: 21 ---
# --- ОТЛАДКА: Добавлены часы. Текущая строка: '12 hours' ---
# --- ОТЛАДКА: Итоговая строка: '12 hours, 21 minutes' ---

========================================



=== ФАЙЛ: ./P2/info.txt ===
Путь: /home/s/Рабочий стол/гит/P2/info.txt
Размер: 4,0K
Дата изменения: 2025-12-28 20:03:37.277185642 +0300

СОДЕРЖИМОЕ:
----------------------------------------
Выдайте права на выполнение: chmod +x system_audit.sh
Запустите: ./system_audit.sh


========================================



=== ФАЙЛ: ./P2/ram.sh ===
Путь: /home/s/Рабочий стол/гит/P2/ram.sh
Размер: 4,0K
Дата изменения: 2026-01-02 16:25:31.182844142 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash

# ОШИБКА БЫЛА ЗДЕСЬ: Мы убрали 'local', так как это основной код скрипта, а не функция.
# Просто объявляем переменные.
ram_total_gb=""
ram_used_gb=""
ram_free_gb=""

# Проверяем наличие утилиты 'free'
if command -v free &>/dev/null; then
    
    # Конструкция подстановки процесса для сохранения данных в текущем окружении
    read -r ram_total_gb ram_used_gb ram_free_gb < <(
        
        # LC_ALL=C гарантирует английский вывод "Mem:" для корректной работы awk
        # free -b дает точность до байта
        LC_ALL=C free -b | awk '/Mem:/ {
            # Конвертируем байты в Гб (деление на 1024 в третьей степени)
            total = $2 / 1024 / 1024 / 1024;
            used  = $3 / 1024 / 1024 / 1024;
            # Берем колонку $4 (Free) строго по заданию Школы 21
            free_m = $4 / 1024 / 1024 / 1024;
            
            # Выводим результат с точностью 3 знака после запятой
            printf "%.3f %.3f %.3f", total, used, free_m
        }'
    )
else
    ram_total_gb="N/A"
    ram_used_gb="N/A"
    ram_free_gb="N/A"
fi

# Выводим результат, чтобы убедиться, что всё работает
echo "RAM_TOTAL = $ram_total_gb GB"
echo "RAM_USED = $ram_used_gb GB"
echo "RAM_FREE = $ram_free_gb GB"

========================================



=== ФАЙЛ: ./P2/system_audit.sh ===
Путь: /home/s/Рабочий стол/гит/P2/system_audit.sh
Размер: 80K
Дата изменения: 2026-01-05 04:56:38.993202856 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash


# СОДЕРЖАНИЕ:


# 1. === БЛОК: НАСТРОЙКА И КОНТРОЛЬ ОКРУЖЕНИЯ ===
# 2. === БЛОК: (timedatectl) ИДЕНТИФИКАЦИЯ ЧАСОВОГО ПОЯСА, ВРЕМЕНИ, СМЕЩЕНИЯ (TIMEZONE) И HOSTNAME (сетевое имя) ===
# 3. === БЛОК: (hostnamectl)  ИДЕНТИФИКАЦИЯ АКТИВНОГО ПОЛЬЗОВАТЕЛЯ И СИСТЕМЫ (USER, OS) ===
# 4. === БЛОК: UPTIME, UPTIME_SEC ===
# 5. === БЛОК: IP, MASK & GATEWAY ===
# 6. === БЛОК 5: RAM_TOTAL, RAM_USED & RAM_FREE ===
# 7. === БЛОК 6: SPACE_ROOT, SPACE_ROOT_USED & SPACE_ROOT_FREE ===
# 8. === БЛОК: ФОРМИРОВАНИЕ ИТОГОВОГО ОТЧЕТА ===
# 9. === БЛОК: ИНТЕРАКТИВНОЕ СОХРАНЕНИЕ В ФАЙЛ ===
# === 10. БЛОК: ГЛАВНАЯ ФУНКЦИЯ ===













# 1. === БЛОК: НАСТРОЙКА И КОНТРОЛЬ ОКРУЖЕНИЯ ===

set -euo pipefail

# Обработка прерывания (Ctrl+C)
trap 'echo -e "

Прервано пользователем."; exit 130' INT TERM


# Команда trap — это встроенный инструмент Bash, который позволяет скрипту «перехватывать» сигналы от операционной системы и выполнять в ответ заданные действия (функции или команды).

# Простыми словами: это обработчик событий. Вы говорите скрипту: «Если произойдет событие Х, сделай действие Y вместо стандартного поведения».

# Опция -e заставляет команду echo интерпретировать (распознавать) экранированные символы с обратным слешем.

# В операционных системах Linux и Unix принято, что если процесс завершился из-за прерывания сигналом, его код выхода должен быть равен 128 + номер сигнала.

#     Сигнал SIGINT (тот самый Ctrl+C) имеет порядковый номер 2.  128+2=130.

# INT и TERM — это сокращенные названия стандартных сигналов, которые операционная система (ядро Linux) посылает программе, чтобы заставить её завершиться. INT (SIGINT)

#     Полное название: SIGINT (Signal Interrupt).

#     Как вызывается: Проще всего — нажатием клавиш Ctrl + C в терминале.

#     Смысл: Это просьба пользователя: «Прерви то, что ты делаешь прямо сейчас, и закройся».


# Почему в скрипте они указаны вместе? В строке trap '...' INT TERM автор объединил их, потому что реакция на них должна быть одинаковой: Независимо от того, нажал ли пользователь Ctrl+C (INT) или систему попросили выключить этот процесс через команду kill (TERM), скрипт должен:    Вывести сообщение «Прервано пользователем».  Завершиться с кодом 130.

# Проверка наличия необходимых команд
check_dependencies() {
    local missing=()
    for cmd in ip awk free df date hostname; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done
    
    # Этот блок кода — финальный вердикт. После того как цикл проверил все команды, этот фрагмент решает: можно ли запускать скрипт дальше или нужно аварийно остановиться.
    # missing — имя нашего массива, куда мы записывали отсутствующие команды.
    #[@] — говорит Bash: «смотри на все элементы массива».
    # # - (в самом начале) — это ключ, который приказывает: «не выводи сами элементы, а просто посчитай их количество».

    if [[ ${#missing[@]} -gt 0 ]]; then # -gt 0 — Сравнение. В Bash для сравнения чисел вместо знака > используются буквы:
        echo "Ошибка: отсутствуют команды: ${missing[*]}" >&2
        exit 1
    fi
}

# Создается локальный пустой массив с именем missing («пропущенные»). В него мы будем записывать названия программ, которых не оказалось на компьютере.

# for cmd - Здесь мы создаем временную переменную с именем cmd (сокращение от command). В эту переменную на каждом шаге цикла будет подставляться одно новое значение из списка.

# Скрипт видит здесь 6 отдельных слов:

#     ip (настройка сети)

#     awk (обработка текста)

#     free (информация о памяти)

#     df (информация о диске)

#     date (время и дата)

#     hostname (имя компьютера)

# 3. ; do

# Это техническое слово-разделитель. Оно говорит Bash: «Список закончен, теперь начинай выполнять команды, которые стоят внутри цикла».

# command -v — это стандартный и самый быстрый способ узнать, установлена ли программа в системе.



# &>/dev/null (Скрытие мусора)- Эта конструкция — «черная дыра» для вывода. Буква & означает «все потоки» (и обычные сообщения, и сообщения об ошибках). >/dev/null — это специальный виртуальный файл в Linux, который просто поглощает любые данные, направленные в него.  Зачем это здесь? Нам не нужно, чтобы при проверке экран засорялся путями типа /bin/ip. Нам важен только результат: «да» или «нет».

# Если команды нет (ошибка) — выполняется missing+=("$cmd"), которая добавляет название этой команды в список отсутствующих.

# Итог всей строки: «Проверь, есть ли команда в системе. Сделай это молча. Если её нет — запиши её имя в список отсутствующих».








































# Сбор системной информации
gather_system_facts() {

# 2. === БЛОК: (timedatectl) ИДЕНТИФИКАЦИЯ ЧАСОВОГО ПОЯСА, ВРЕМЕНИ, СМЕЩЕНИЯ (TIMEZONE) И HOSTNAME (сетевое имя) ===


    # Имя хоста
    local node_name
    node_name=$(hostname -s 2>/dev/null || hostname)

    # Команда hostname выводит полное доменное имя компьютера. Опция -s (или --short) заставляет её выводить только короткое имя без домена.
    # 2>/dev/null - Это уже знакомая нам «заглушка». Она перенаправляет поток ошибок (канал 2) в «пустоту». Таким образом, если команда hostname выдаст ошибку (что маловероятно, но всё же), сообщение об ошибке не будет показано пользователю.

    # || hostname (Логическое ИЛИ) - Это запасной план.  Если первая часть (hostname -s) по какой-то причине завершилась с ошибкой (например, команда не поняла флаг -s), то благодаря оператору || выполнится вторая часть — просто команда hostname без флагов.



    # Временная зона с расчётом UTC-смещения
    local tz_name tz_offset # здесь объявляются сразу две переменные — tz_name (для названия временной зоны, например Europe/Moscow) и tz_offset (для числового смещения, например +3).

    # command -v timedatectl &>/dev/null - Проверка наличия команды timedatectl в системе. 
    # timedatectl status &>/dev/null - Это проверка на работоспособность.  Бывает так, что программа timedatectl в системе есть, но она не работает. Например, если система запущена без systemd (которым управляет эта утилита), команда выдаст ошибку: «Failed to create bus connection».Вызывая status, мы убеждаемся, что утилита не просто «висит мертвым грузом», а способна отдавать данные.


    if command -v timedatectl &>/dev/null && timedatectl status &>/dev/null; then
        tz_name=$(timedatectl show --value --property=Timezone 2>/dev/null)

        # --property=Timezone: мы просим показать только одну конкретную настройку — часовой пояс.

        [[ -z "$tz_name" ]] && tz_name="UTC"  # «Если переменная tz_name оказалась пустой, то запиши в неё текст "UTC"».

        # UTC в этой строчке — это «безопасная гавань». Если скрипт не смог определить, где находится сервер (в Токио или Париже), он говорит: «Окей, тогда будем считать по мировому стандарту». UTC — это «нулевой меридиан» для времени. Все остальные часовые пояса считаются как смещение от него (например, UTC+3 или UTC-5). Если мы не знаем локальное время сервера, безопаснее всего показать время в «нулевой» зоне, так как любой администратор в мире поймет, как соотнести его со своим временем.


        # Попытка получить смещение в формате -5 или +3
        tz_offset=$(date +"%:::z" 2>/dev/null || date +"%z" | sed 's/\([+-][0-9][0-9]\).*/\1/' | sed 's/0\([0-9]\)/\1/')
        # 1. План А: Современный способ. date +"%:::z" 2>/dev/null. Команда date с флагом +"%:::z" (три двоеточия) в современных системах выводит смещение в самом простом виде: например, +03 или -05.

        # План Б: Старый способ + «хирургия» текста. date +"%z" | sed 's/\([+-][0-9][0-9]\).*/\1/' | sed 's/0\([0-9]\)/\1/'
        # Тут происходит цепочка превращений:
        # date +"%z": Выдает стандартное смещение из 4 цифр, например +0300.
        # Первый sed: Обрезает лишние нули в конце.
        #   Было: +0300 -> Стало: +03.
        #   Регулярное выражение ищет плюс/минус и две цифры, а всё остальное отбрасывает.
        #Второй sed: Убирает ведущий ноль, если он есть.
        #   Было: +03 -> Стало: +3.
        #   Это делается для красоты, чтобы в отчете не было лишних цифр.


    else
        tz_name="UTC"
        tz_offset="0"
    fi

    # tz_name="UTC": Мы принудительно устанавливаем название зоны как «Всемирное координированное время». Это самый безопасный стандарт (как мы обсуждали ранее).
    # tz_offset="0": Поскольку UTC — это нулевой меридиан, смещение от него равно нулю.
    # Это защита от сбоя. Автор скрипта гарантирует, что переменные tz_name и tz_offset будут определены в любом случае, на любом «железе».




































# 3. === БЛОК: (hostnamectl)  ИДЕНТИФИКАЦИЯ АКТИВНОГО ПОЛЬЗОВАТЕЛЯ И СИСТЕМЫ (USER, OS) ===


    # Пользователь
    local active_user
    active_user=$(whoami)

    # Операционная система
    local os_release

    # Команда command с опцией -v — это встроенный инструмент Bash, который используется для проверки существования программы в системе и определения пути к ней.

    # -v (verbose/value): Эта опция заставляет команду не запускать программу, а просто вывести путь к её исполняемому файлу. Если программа установлена, команда вернет её полный путь (например, /usr/bin/ls). Если программа не найдена, команда вернет ошибку.

    # hostnamectl  — это основной способ в современных Linux-системах (использующих systemd) получить краткую сводку о конфигурации системы.

    # status — это подкоманда (аргумент), которая приказывает утилите показать текущее состояние системы.

    # МЕТОД 1: Современный (systemd). Самый информативный.
    # Проверяем: 1) есть ли сама утилита hostnamectl, 2) может ли она выдать статус (работает ли dbus)

    # D-Bus (Desktop Bus) — это «почтовая служба» или «шина сообщений» внутри Linux. Она позволяет разным программам в системе общаться друг с другом, даже если они написаны на разных языках программирования и работают как абсолютно независимые процессы.

    if command -v hostnamectl &>/dev/null && hostnamectl status &>/dev/null; then
        # Берем вывод hostnamectl, ищем строку "Operating System", 
        # делим её по разделителю ": " и забираем вторую часть (само название ОС)
        os_release=$(hostnamectl | awk -F': ' '/Operating System/ {print $2; exit}')
          # AWK — это не просто команда, а целый язык программирования, специально созданный для обработки текста, структурированного в виде колонок или строк (таблиц, логов, конфигов). Его название — это аббревиатура из первых букв фамилий создателей: Aho, Weinberger, Kernighan.

          # Флаг -F (Field Separator) указывает awk, какой символ считать «границей» между колонками.    В выводе hostnamectl строки выглядят так: Operating System: Ubuntu 22.04.    Мы говорим: «Разделителем является двоеточие с последующим пробелом (: )».    Теперь для awk всё, что до двоеточия — это поле №1, а всё, что после — поле №2.

          # {print $2; exit} (Действие) - Это то, что нужно сделать, когда строка найдена:    print $2: Напечатать содержимое второго поля (то есть всё, что идет после : ).    ; exit: Это очень важная деталь. Как только мы нашли нужную строку и напечатали её, мы немедленно прекращаем работу. Нам не нужно читать оставшиеся 10 строк вывода команды — это экономит время.

    # МЕТОД 2: Традиционный (LSB - Linux Standard Base).
    # Если hostnamectl недоступен, проверяем наличие утилиты lsb_release (часто есть в Ubuntu/Debian)
    # lsb_release — это стандартная системная утилита в Linux, которая выводит специфическую информацию о вашем дистрибутиве (название, версию, кодовое имя).

    elif command -v lsb_release &>/dev/null; then
    # Вызываем описание системы (-d), скрываем ошибки и вырезаем только название (второе поле) - Description
    # Здесь два поля:        Поле 1: Description:        Поле 2: Ubuntu 22.04.3 LTS  . Команда cut -f2 просто выбрасывает первое поле и оставляет только второе. В итоге в переменную os_release попадает чистое название системы без лишних слов.
        os_release=$(lsb_release -d 2>/dev/null | cut -f2)
    else
    # МЕТОД 3: Универсальный (POSIX).
    # Если всё вышеперечисленное не сработало (например, в минимальном Docker-контейнере)
    # uname -Она запрашивает у ядра операционной системы данные о железе и программной платформе. Эта команда есть абсолютно в любой Linux-системе, даже в самой крошечной (например, в роутерах или умных чайниках), потому что она является частью стандарта POSIX.

    # Опция -s (kernel-sysname) - Эта опция приказывает команде вывести только название ядра.

    # Если даже uname упал, пишем "Unknown", чтобы переменная не осталась пустой.
        os_release=$(uname -s 2>/dev/null || echo "Unknown")
    fi

    # Текущее время в требуемом формате (портабельная версия)
    local current_moment
    current_moment=$(LC_TIME=C date +"%d %b %Y %H:%M:%S" | sed 's/^0//')
    # Команда date выводит системное время, а знак + указывает, что мы хотим использовать собственный формат вывода. # 30 дек 2025 12:09:50

    # Здесь результат работы date передается «по конвейеру» команде sed, которая занимается поиском и заменой текста.

    # s — Сокращение от substitute (заменить).

    # / — Разделители частей команды.

    # ^0 — Это регулярное выражение.

    #     Символ ^ означает «начало строки».

    #     Цифра 0 — это то, что мы ищем.

    #     Вместе ^0 значит: «найди ноль, только если он стоит в самом начале текста».

    # // — Между этими слешами пусто. Это значит «заменить на ничто» (то есть просто удалить).






























# 4. === БЛОК: UPTIME, UPTIME_SEC ===



    # Время работы системы

    # Этот блок кода очень гибкий. Благодаря проверкам на «единственное/множественное число» и условию if [[ $days -gt 0 ]], вывод меняется в зависимости от того, как долго работает сервер.

    # Объявляем локальные переменные, которые будут видны только внутри этой функции
    # uptime_human — для итоговой строки (напр., "2 days, 3 hours")
    # uptime_seconds — для хранения общего количества секунд работы
    local uptime_human uptime_seconds


    # Проверяем, существует ли файл /proc/uptime
    # Это виртуальный файл в Linux, который содержит данные о времени работы ядра
    if [[ -f /proc/uptime ]]; then

        # Извлекаем количество секунд из файла и округляем их
        # $(...) — подстановка результата команды в переменную
        # awk '{printf "%.0f", $1}' — берет первое число из файла и округляет до целого
        uptime_seconds=$(awk '{printf "%.0f", $1}' /proc/uptime)
      
        
        # Расчёт времени работы вручную для портабельности. Объявляем локальные переменные для хранения результатов деления
        local days hours mins


        # 1. Считаем полные дни
        # В одном дне 86400 секунд (24 * 60 * 60).
        # Целочисленное деление отсекает остаток.
        days=$((uptime_seconds / 86400))
        
        # 2. Считаем оставшиеся часы
        # % 86400 — находим остаток секунд, которые не "вместились" в полные дни.
        # Делим этот остаток на 3600 (секунд в 1 часе).
        hours=$(((uptime_seconds % 86400) / 3600))

        
        # 3. Считаем оставшиеся минуты
        # % 3600 — находим остаток секунд, которые не "вместились" в полные часы.
        # Делим на 60 (секунд в 1 минуте).
        mins=$(((uptime_seconds % 3600) / 60))


        # 1. Сначала создаем пустую переменную для "человеческого" аптайма. (Human-readable uptime) — это способ отображения времени работы системы не в виде огромного числа секунд, а в формате, который понятен любому человеку с первого взгляда.
        
        uptime_human=""

        # 2. Проверяем, есть ли хотя бы один полный день работы
        if [[ $days -gt 0 ]]; then

            # 3. Грамматическая проверка (единственное или множественное число):
            # Если день ровно 1 ($days -eq 1), пишем "1 day"
            # В противном случае (||) пишем, например, "5 days"
            [[ $days -eq 1 ]] && uptime_human="${days} day" || uptime_human="${days} days"

            # Добавляем запятую после дней (если они были добавлены ранее),
            # так как дальше в строку добавятся часы и минуты
            uptime_human+=", "
        fi
        # 1. Считаем и форматируем ЧАСЫ
        # Если час ровно 1 ($hours -eq 1), добавляем строку "1 hour"
        # В противном случае (||) добавляем, например, "5 hours" // Если часов не 1 (например, 0 или 5), выполнится часть после ||: 5 hours.
        [[ $hours -eq 1 ]] && uptime_human+="${hours} hour" || uptime_human+="${hours} hours"
        uptime_human+=", "
        [[ $mins -eq 1 ]] && uptime_human+="${mins} minute" || uptime_human+="${mins} minutes"
    else

        # от английского Not Available (Недоступно) или Not Applicable (Не применимо). Он срабатывает в том случае, если скрипту не удалось найти системный файл /proc/uptime.
        uptime_seconds="N/A"
        uptime_human="N/A"
    fi





























# 5. === БЛОК: IP, MASK & GATEWAY ===



    # Сетевая информация
    local main_iface
    # Как узнать, какой сетевой интерфейс (карта) сейчас главный? 
    # Мы «спрашиваем» систему: «Если я захочу отправить пакет по адресу 8.8.8.8 (DNS Google), какой путь ты выберешь?»
    # Команда ip route get имитирует отправку и показывает маршрут.
    # AWK забирает 5-е слово из вывода — это и есть название интерфейса (например, eth0 или wlan0).
    # || echo "eth0" — это «костыль надежности»: если интернет отключен и маршрут не найден, мы просто предположим, что имя карты стандартное.
    main_iface=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}' || echo "eth0")

    local machine_ip subnet_mask default_gateway
    # Здесь мы вытягиваем IP-адрес. 
    # ip -4 addr show — показывает только IPv4 адреса для выбранного интерфейса - awk '/inet/' — ищет строку, содержащую "inet" (там лежит адрес).
    # cut -d'/' -f1 — адрес обычно идет в виде 192.168.1.5/24. Эта команда «отрезает» всё, что после слеша, оставляя чистый IP.
    machine_ip=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f1)  
    # По умолчанию cut думает, что колонки разделены символом табуляции. Но в сетевых адресах (например, 192.168.1.5/24) колонки разделены косой чертой /.  Зачем нужна: Она говорит команде: «Считай, что граница между частями строки — это символ, который я укажу следом». В нашем случае -d'/' означает: «Используй / как нож, чтобы разрезать строку».
    # Команда видит -f1: Она берет первый кусок и выбрасывает остальное.

    [[ -z "$machine_ip" ]] && machine_ip="N/A"

    # Флаг -z — (от англ. zero) проверяет, является ли строка пустой (нулевой длины).
    # Если переменная с IP-адресом пустая, то запиши в неё текст "N/A"


    # Расчёт маски из CIDR-префикса (улучшенная версия)
    # CIDR — это то самое число после слеша (например, /24). 
    # Системе проще хранить длину префикса, но человеку привычнее видеть маску типа 255.255.255.0.
    # CIDR — это аббревиатура, которая расшифровывается как Classless Inter-Domain Routing. На русском это звучит как «Бесклассовая адресация» (или буквально: Бесклассовая междоменная маршрутизация).
    local cidr_prefix
    cidr_prefix=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f2)
    
    if [[ -n "$cidr_prefix" ]]; then  # Опция -n (Non-zero)
        # Начинается магия AWK. Поскольку Bash не умеет в сложные вычисления, мы передаем задачу сюда.

        # Буква v здесь — сокращение от Variable (переменная). Её главная задача: Передать значение из «мира Bash» внутрь «мира AWK». редставь, что Bash и AWK — это два соседа, которые говорят на разных языках и живут за высоким забором.   Bash — это твой основной скрипт. В нём лежит переменная $cidr_prefix (например, число 24).    AWK — это отдельная программа, которую Bash вызывает для расчетов.AWK не может просто «залезть» в память Bash и взять оттуда переменную. Для него $cidr_prefix — это просто пустой звук. Чтобы AWK узнал это число, нам нужно передать его «через забор». Опция -v как раз и перебрасывает эту переменную.
        
        # Опция -v (variable): Это «мостик» между Bash и AWK. В Bash у нас есть переменная $cidr_prefix (например, число 24). Но внутри AWK свои правила, и он не видит переменные Bash напрямую.
        # Что делает BEGIN? Обычно AWK работает как «читатель»: он открывает файл и выполняет команды для каждой строки, которую найдет. Но что если нам не нужно ничего читать? Что если мы просто хотим использовать AWK как калькулятор? Для этого существует специальный блок BEGIN.    Смысл: Это команда: «Сделай это немедленно, еще до того, как начнешь читать какой-либо файл или входящий текст».    Зачем это здесь: В нашем случае нам не нужно обрабатывать лог-файлы. Нам нужно просто взять число 24 и превратить его в 255.255.255.0. Поэтому мы пишем весь код внутри BEGIN { ... }.    Итог: AWK запускается, делает расчет, печатает результат и тут же закрывается.

        #Весь код AWK, включая BEGIN, обернут в одинарные кавычки: awk '...'. Это сделано не для AWK, а для Bash (основного языка твоего скрипта).  Одинарные кавычки говорят Bash: «Всё, что находится внутри, — это просто текст. Не трогай его, не пытайся его расшифровать, просто передай его программе AWK целиком, как есть».

        subnet_mask=$(awk -v prefix="$cidr_prefix" 'BEGIN {
            # Проверка на дурака: префикс не может быть меньше 0 или больше 32 (бит в IPv4).
            if (prefix == "" || prefix < 0 || prefix > 32) {
                print "N/A";
                exit;
            }
            
            # Расчёт маски через битовые операции:
            # Представьте маску как 32 ячейки, которые заполняются единицами.
            # Если префикс 24, мы ставим 24 единицы в ряд, а остальные 8 забиваем нулями.
            mask = 0;
            for (i = 0; i < prefix; i++) {
                mask = mask * 2 + 1;
            }


1. Пошаговая работа цикла (для prefix = 3)

Изначально переменная mask = 0. Цикл должен выполниться 3 раза.

Шаг 1 (i = 0):

    Берем 0.

    Считаем: 0 * 2 + 1 = 1.

    В двоичном виде это: 1.

Шаг 2 (i = 1):

    Берем 1.

    Считаем: 1 * 2 + 1 = 3.

    В двоичном виде это: 11. (Видишь? Мы просто приставили еще одну единицу справа).

Шаг 3 (i = 2):

    Берем 3.

    Считаем: 3 * 2 + 1 = 7.

    В двоичном виде это: 111.

Результат: мы получили число, которое в двоичной системе состоит из трех единиц. Если префикс будет 24, цикл «нарисует» в памяти компьютера цепочку из 24 единиц.
2. Зачем это нужно для сетевой маски?

Сетевая маска — это всегда ряд единиц, за которым следует ряд нулей.

    Если маска /24, то это 24 единицы и 8 нулей (всего 32 бита).

    Этот цикл выполняет первую часть задачи — формирует цепочку из единиц, соответствующую длине префикса.














            for (i = prefix; i < 32; i++) {
                mask = mask * 2;
            }









# Магия умножения на 2 (без единицы)

# Как мы уже выяснили:

#     mask * 2 + 1 — добавляет в конец единицу.

#     mask * 2 (просто умножение) — сдвигает число влево и добавляет в конец ноль.

# Шаг за шагом (продолжаем пример с /3): После первого цикла у нас было 111 (число 7). Нам нужно «добить» его до 32 бит. Этот цикл начнет работу с i = 3 и пойдет до 32.

#     Шаг (i = 3): 111 превращается в 1110 (число 14).

#     Шаг (i = 4): 1110 превращается в 11100 (число 28). ... и так далее, пока в числе не станет 32 знака.















# Откуда взялись эти странные числа?

#     256 — это 2^8 (вес одного байта).

#     65536 — это 2^16 (вес двух байтов: 256×256).

#     16777216 — это 2^24 (вес трех байтов: 256×256×256).



# Как работает расчет (Разбор «мясорубки»)

#     octet1 = int(mask / 16777216) % 256 Мы делим наше гигантское число на вес трех младших байтов. Это как бы «отбрасывает» три правых октета и сдвигает самый левый октет на первое место. Остаток от деления % 256 гарантирует, что число не выйдет за границы одного байта.

#     octet4 = mask % 256 Это самое простое. Оператор % (остаток от деления) просто отрезает всё лишнее и оставляет только то, что «не влезло» в полные байты — то есть самый правый «хвостик» числа.


            
            # Теперь у нас есть одно огромное число. Чтобы превратить его в привычный вид (X.X.X.X), мы делим его на части (октеты).
            # 16777216, 65536 и 256 — это математические «веса» каждого байта в 32-битном числе.
            octet1 = int(mask / 16777216) % 256;
            octet2 = int(mask / 65536) % 256;
            octet3 = int(mask / 256) % 256;
            octet4 = mask % 256;
            
            # Склеиваем всё точками обратно.
            printf "%d.%d.%d.%d", octet1, octet2, octet3, octet4;

















# После первых двух циклов в нашем скрипте переменная mask превратилась в число, которое в двоичной системе выглядит так: 11100000 00000000 00000000 00000000

# В обычном десятичном виде это огромное число: 3 758 096 384.

# Теперь давай пропустим его через наши формулы:
# 1. Считаем первый октет (octet1)

# octet1 = int(3758096384 / 16777216) % 256

#     Делим: 3758096384/16777216=224 ровно.

#     Берем целое: int(224) — это 224.

#     Остаток: 224%256=224 (так как 224 меньше 256, оно остается собой).

#     Результат: Первый октет маски равен 224.

# 2. Считаем второй октет (octet2)

# octet2 = int(3758096384 / 65536) % 256

#     Делим: 3758096384/65536=57344.

#     Берем целое: 57344.

#     Остаток от 256: 57344/256=224 ровно, остаток 0.

#     Результат: Второй октет равен 0.

# 3. Третий и четвертый октеты

# С ними происходит то же самое:

#     octet3: 3758096384/256=14680064. Делим на 256 — остаток 0.

#     octet4: 3758096384%256=0.

# Итоговый результат:

# Команда printf берет эти цифры и склеивает их: 224.0.0.0
# Почему это работает? (Наглядная схема)

# Представь, что наше огромное число — это 32-битная лента. Числа-делители работают как линейка:

#     16777216 — это начало 4-го байта (самого левого).

#     65536 — начало 3-го байта.

#     256 — начало 2-го байта.

# Когда мы делим на эти числа, мы как бы сдвигаем ленту вправо, чтобы нужный нам кусок оказался в самом начале (в единицах), а потом с помощью % 256 просто «откусываем» этот кусок.

#     Итог: Для маски /3 наш калькулятор выдаст 224.0.0.0. Если бы ты взял привычную маску /24, расчет бы выдал 255.255.255.0. Математика одна и та же!














        }')
    else
        subnet_mask="N/A"
    fi

    # Шлюз по умолчанию (Default Gateway)
    # Это адрес роутера, через который компьютер выходит в большой мир.
    # Мы ищем в таблице маршрутизации строку со словом "default" и берем 3-й столбец.
    default_gateway=$(ip route 2>/dev/null | awk '/default/ {print $3; exit}')
    [[ -z "$default_gateway" ]] && default_gateway="N/A"


    # Разбор конструкции 2>/dev/null (Перенаправление ошибок в «черную дыру»): 
    # 2 — Мы говорим системе: «Смотри именно на канал номер 2 (ошибки)».
    # > — Это символ перенаправления. Он работает как стрелка: «Возьми то, что летит в канал 2, и отправь это в другое место».
    # /dev/null — Это специальный виртуальный файл в Linux, который называют «черной дырой». Всё, что ты в него записываешь, просто исчезает навсегда.



















# 6. === БЛОК 5: RAM_TOTAL, RAM_USED & RAM_FREE ===


    # Цель: Получить данные о памяти в Гб с точностью до 3 знаков после запятой.
    

    # ram_total_gb (Total RAM)    Что это: Весь объем оперативной памяти, который видит твоя операционная система.
    # ram_used_gb (Used RAM)    Что это: Память, которая занята прямо сейчас. Это работающие программы, запущенные скрипты, базы данных и сама система.
    # ram_free_gb (Free RAM)    Что это: Память, которая свободна и готова к использованию. (free — это именно «пустая» память, а не «available», которая включает в себя кэш).

    local ram_total_gb ram_used_gb ram_free_gb

    # Проверка наличия утилиты free. Если её нет (редкость, но бывает в микро-контейнерах),
    # -v: Говорит: «Не запускай команду, просто покажи мне путь к файлу или описание». 
    if command -v free &>/dev/null; then
        
        # 'read -r' — считывает строку и распределяет слова по переменным.
        # Флаг '-r' отключает интерпретацию экранирующих символов (защита данных).
        # Конструкция < <(...) — это Process Substitution (подстановка процесса).
        # ЗАЧЕМ МЫ ЭТО СДЕЛАЛИ: Если использовать обычный конвейер (free | read), команда read выполнится в дочерней оболочке (subshell), и переменные  исчезнут сразу после выхода из неё. Метод < <(...) позволяет сохранить значения переменных в основном процессе скрипта.
        read -r ram_total_gb ram_used_gb ram_free_gb < <(

            # Расшифровка по частям:
                # 1. LC (Locale Category): Первые две буквы расшифровываются как Locale Category (Категория локали). Локаль — это набор настроек, который определяет язык интерфейса, формат даты, времени, денежных знаков и способ сортировки текста в системе.
                # 2. ALL: Указывает, что мы хотим применить настройки ко всем возможным категориям сразу.
                    # (В Linux есть отдельные настройки: LC_TIME для времени, LC_NUMERIC для чисел, LC_MESSAGES для текста ошибок). LC_ALL — это «мастер-ключ», который перекрывает их все.
                # 3.  C (Standard C Locale): Буква «C» здесь — это не просто буква. Это название стандартной системной локали, также известной как POSIX.
                    # Она называется «С» в честь языка программирования C, на котором написан Linux.
                    # Это «родной» язык операционной системы. Он максимально простой, всегда на английском, и в нем нет никаких региональных особенностей (например, в качестве разделителя в числах всегда используется точка, а не запятая).

                # Как это «читает» система?
                # «На время выполнения этой команды забудь, что пользователь живет в России и говорит по-русски. Используй стандартный английский системный формат (C), чтобы вывод был предсказуемым для скрипта».
            
            # ИЗМЕНЕНИЕ №1: LC_ALL=C
            # ПОЧЕМУ: Это принудительная установка стандартной локали (английский язык).
            # На твоем ноутбуке команда 'free' выводит "Память:", а awk ищет "Mem:".
            # Без LC_ALL=C скрипт сломается на любой системе с неанглийским языком.
            # Это делает твой код портабельным и профессиональным.
            
            # ИЗМЕНЕНИЕ №2: free -b
            # ПОЧЕМУ: Опция '-b' выводит данные в байтах. Стандартные '-m' или '-g' выполняют грубое округление на стороне самой утилиты. Чтобы получить точность "хирурга" (3 знака после запятой), мы берем сырые байты  и передаем их для точных вычислений в awk.
            
            LC_ALL=C free -b | awk '/Mem:/ {
                
                # Внутри AWK мы работаем с колонками вывода 'free -b':
                # $2 - total (всего), $3 - used (занято), $4 - free (свободно).
                
                # В Linux 1 Гб = 1024 * 1024 * 1024 байт.
                # Выполняем цепочку делений для перевода единиц измерения.

                total_res = $2 / 1024 / 1024 / 1024;
                used_res  = $3 / 1024 / 1024 / 1024;
                
                # ИЗМЕНЕНИЕ №3: Использование колонки $4 (free_m)
                # ПОЧЕМУ: В предыдущей версии мы использовали $7 (available). 
                # Однако ТЗ Школы 21 требует именно RAM_FREE. 
                # В Linux "Free" — это абсолютно пустая память (колонка $4), 
                # а "Available" — это свободная память плюс кэш. 
                # Чтобы пройти автотесты и строго соблюсти задание, мы берем именно $4.

                free_res  = $4 / 1024 / 1024 / 1024;
                
                # 'printf' формирует итоговую строку. 
                # "%.3f" — спецификатор типа float с 3 знаками после запятой.
                # Числа выводятся через пробел, чтобы команда 'read' выше 
                # смогла разложить их по трем разным "карманам" (переменным).
                printf "%.3f %.3f %.3f", total_res, used_res, free_res
            }'
        )













# В контексте программы `awk`, переменные со знаком доллара и цифрой (**$1, $2, $3...**) — это **номера столбцов (полей)** в строке текста.

# Когда ты передаешь вывод команды `free -b` в `awk`, тот воспринимает каждую строку как таблицу, где столбцы разделены пробелами.

# ### Как `awk` видит твой вывод:

# Давай разберем строку «Память», которую выдала твоя система:

# | $1 (Поле 1)  | $2 (Поле 2)     |   $3 (Поле 3)   |   $4 (Поле 4)     |    $5     |       $6     |      $7     |
# | ------------ | --------------- | --------------- | ----------------- | --------- | ------------ | ----------- |
# | **Память:**  | **16137207808** | **6133673984**  | **4748791808**    | 123330560 | 4034924544   | 10003533824 |
# | *(Название)* | *(Всего/Total)* | *(Занято/Used)* | *(Свободно/Free)* | (Shared)  | (Buff/Cache) | (Available) |

# ### Почему они приобретают эти значения?

# 1. **Поиск строки:** Команда `awk '/Mem:/'` (или в твоем случае с локалью `LC_ALL=C`) ищет строку, в которой есть это слово. Как только `awk` находит нужную строку, он «разрезает» её на куски по пробелам.
# 2. **Присваивание:** * **$1** становится равным названию строки.
# * **$2** забирает число из второго столбца (Total).
# * **$3** забирает число из третьего столбца (Used).
# * **$4** забирает число из четвертого столбца (Free).


# 3. **Автоматическое приведение типов:** Хотя для системы это просто текст, `awk` — умный инструмент. Когда он видит, что ты пытаешься совершить математическое действие (например, `$2 / 1024`), он сам превращает текст `16137207808` в число и считает его.















# В этих строчках происходит **математическое преобразование единиц измерения**: мы переводим огромные числа из «сырых» байтов в человекочитаемые гигабайты.

# Вот подробный разбор того, что делает каждая часть этой формулы:

# ### 1. Что такое $2, $3, $4?

# Это колонки из вывода команды `free -b`. Поскольку мы запустили её с флагом `-b` (bytes), система выдает нам значения в байтах:

# * `$2` (total) — например, `17179869184` байт.
# * `$3` (used) — например, `4294967296` байт.
# * `$4` (free) — например, `2147483648` байт.

# Работать с такими длинными числами неудобно, поэтому мы их конвертируем.

# ---

# ### 2. Почему мы делим на 1024 три раза?

# В компьютерном мире переход между единицами измерения памяти кратен числу **1024** (). Каждое деление поднимает нас на один уровень иерархии выше:

# 1. **Первое деление (`/ 1024`):** Переводит **Байты** в **Килобайты** (Кб).
# 2. **Второе деление (`/ 1024`):** Переводит **Килобайты** в **Мегабайты** (Мб).
# 3. **Третье деление (`/ 1024`):** Переводит **Мегабайты** в **Гигабайты** (Гб).

# > **Математическая справка:** Делить три раза на 1024 — это то же самое, что разделить один раз на  (на **1 073 741 824**).

# ---

# ### 3. Зачем это делать внутри AWK?

# Это критически важный момент для Bash-скриптов:

# * **Ограничение Bash:** Стандартный интерпретатор Bash умеет работать **только с целыми числами**. Если ты попробуешь разделить `5 / 2`, Bash выдаст `2`, просто отбросив всё после запятой.
# * **Сила AWK:** Утилита `awk` — это полноценный язык программирования, который поддерживает числа с плавающей точкой (дробные числа).

# Именно благодаря `awk` мы можем получить не просто «15 Гб», а точный результат «15.029 Гб», как того требует задание Школы 21.

# ---

# ### Итоговый смысл каждой строки:

# * `total = $2 / 1024 / 1024 / 1024;`
# * *«Возьми общее количество байтов и узнай, сколько это целых и дробных гигабайтов».*


# * `used = $3 / 1024 / 1024 / 1024;`
# * *«Узнай, сколько Гб памяти сейчас реально занято процессами».*


# * `free_m = $4 / 1024 / 1024 / 1024;`
# * *«Узнай, сколько Гб памяти простаивает абсолютно впустую».*



# Затем эти результаты попадают в `printf "%.3f"`, который просто обрезает «хвост» числа, оставляя ровно три знака после точки.

    else
        # Если утилита 'free' не установлена (например, в минимальном Docker-образе),
        # мы присваиваем переменным значение "N/A" (Not Available).
        # Это предотвращает пустые строки в отчете и делает вывод предсказуемым.
        ram_total_gb="N/A"
        ram_used_gb="N/A"
        ram_free_gb="N/A"
    fi




























































# 7. === БЛОК 6: SPACE_ROOT, SPACE_ROOT_USED & SPACE_ROOT_FREE ===


# В контексте Linux и твоего задания, рутовый раздел (от англ. root — корень) — это главный раздел твоего жесткого диска или SSD, на котором установлена сама операционная система.

# Информация о диске
# Root Space	df	Физический накопитель (SSD/HDD). Данные хранятся постоянно, даже при выключении питания.
# Цель: Получить данные о дисковом пространстве корневого раздела (/) в Мб с точностью до 2 знаков после запятой.

    local root_total_mb root_used_mb root_free_mb
    
    # Проверка наличия утилиты df (Disk Free).
    if command -v df &>/dev/null; then
        
        # Конструкция < <(...) — «Подстановка процесса» (Process Substitution). она заставляет вывод команды выглядеть для системы как временный файл.
        # 1. Как это расшифровывается? Эта конструкция состоит из двух разных операторов, которые пишутся вместе:
            # <( ... ) (Внутренняя часть): Запускает команду внутри скобок и создает в оперативной памяти «трубу» (named pipe), которая для системы выглядит как файл по адресу /dev/fd/63 (номер может меняться).
            # < (Внешний левый знак): Это обычный оператор перенаправления ввода. Он говорит команде read: «Возьми данные не из клавиатуры, а из файла, который стоит справа».
            # Итог: Команда read думает, что читает данные из обычного текстового файла, хотя на самом деле она читает их напрямую из вывода awk.
        
        # Это подстановка процесса. Мы используем её вместе с командой read, чтобы избежать создания дочерней оболочки (subshell), которую порождает обычный конвейер. Это позволяет сохранить значения переменных в основном теле скрипта


        # Почему нельзя просто написать: df | awk | read ... ?
        # Потому что в Bash пайп (|) создает дочерний процесс. Переменные, заполненные внутри пайпа, умирают вместе с ним и не попадают в основной скрипт.
        # < <(...) создает временный «файл-призрак» (дескриптор), который команда read может прочитать, оставаясь в текущем процессе. Так переменные сохраняются.
        
        read -r root_total_mb root_used_mb root_free_mb < <(
            
            # df -B1 /
            # Мы проверяем корень системы (/). В Linux / — это не просто "корень", это точка монтирования (mount point). какое  устройство хранения  (например, /dev/nvme0n1p2 или /dev/sda3) привязано к этой точке. Если ты просто напишешь df, команда выведет список всех примонтированных файловых систем (включая временные tmpfs, петлевые loop от snap-пакетов и сетевые диски). Указание / жестко ограничивает выборку только одной конкретной файловой системой, в которой живет вся твоя ОС. Например /dev/nvme0n1p5 после команды - df  / 

            # Опция -B1 (Block size = 1 byte) заставляет df выводить размеры строго в байтах.
            # Зачем? Если использовать df -h (human readable), он выдаст "20G".
            # С текстом "20G" математику не сделаешь, нам нужны «голые» цифры для точности.
            # 2>/dev/null — глушим ошибки, если вдруг прав нет (хотя на df они обычно есть).
            # awk 'NR==2' — (Number of Record) ВЫВЕСТИ ТОЛЬКО 2-Ю СТРОКУ ВЫВОДА БЕЗ НАЗВАНИЯ СТОЛБЦОВ
            
            df -B1 / 2>/dev/null | awk 'NR==2 {
                
                # Вывод команды df всегда состоит из двух строк:
                # Строка 1: Заголовки (Filesystem 1B-blocks Used Available...)
                # Строка 2: Сами цифры.
                # Мы говорим AWK: «Игнорируй первую строку, начинай работать только когда номер строки (NR) равен 2».
                
                # Математика:
                # Мы получили байты, а хотим мегабайты (MB).
                # Делим на 1024 (получаем КБ), потом еще раз на 1024 (получаем МБ).
                total = $2/1024/1024;
                used = $3/1024/1024;
                free = $4/1024/1024;
                
                # Форматируем: %.2f оставляет 2 знака после запятой.
                printf "%.2f %.2f %.2f", total, used, free
            }'
        )
    else
        # Заглушка на случай, если df нет (например, в микро-контейнере)
        root_total_mb="N/A"
        root_used_mb="N/A"
        root_free_mb="N/A"
    fi
























# 8. === БЛОК: ФОРМИРОВАНИЕ ИТОГОВОГО ОТЧЕТА ===


    # cat <<EOF — Это конструкция под названием "Here Document" (Heredoc).
    # Простыми словами: это способ сказать Bash: «Сейчас я вывалю на тебя целую кучу текста, просто печатай всё подряд, пока не встретишь слово EOF (End Of File)».
    
    # Почему это круто? Тебе не нужно писать команду echo перед каждой строчкой. 
    # Ты просто рисуешь шаблон будущего отчета прямо в коде, и Bash сам подставит значения переменных в нужные места.
    
    cat <<EOF
HOSTNAME = $node_name
TIMEZONE = $tz_name UTC $tz_offset
USER = $active_user
OS = $os_release
DATE = $current_moment
UPTIME = $uptime_human
UPTIME_SEC = ${uptime_seconds} seconds
IP = $machine_ip
MASK = $subnet_mask
GATEWAY = $default_gateway
RAM_TOTAL = ${ram_total_gb} GB
RAM_USED = ${ram_used_gb} GB
RAM_FREE = ${ram_free_gb} GB
SPACE_ROOT = ${root_total_mb} MB
SPACE_ROOT_USED = ${root_used_mb} MB
SPACE_ROOT_FREE = ${root_free_mb} MB
EOF
    # EOF — это «стоп-сигнал». Когда Bash видит это слово в начале строки, 
    # он понимает: «Ага, многострочный ввод закончен, закрываем поток».
}





























# 9. === БЛОК: ИНТЕРАКТИВНОЕ СОХРАНЕНИЕ В ФАЙЛ ===




# # Разбор строки: local facts_snapshot="$1"
# Текст не берется из ниоткуда. Он проходит путь от **создания** до **приема**.

# ### 1. Как данные попадают в $1? (Внешняя связь)

# В Bash `$1` — это **первый аргумент**, который передали функции при её вызове.

# Посмотри в самый низ своего скрипта, в функцию `main`. Там есть две ключевые строчки:

# ```bash
# # 1. Мы запускаем сбор данных и сохраняем ВЕСЬ текст в переменную system_report
# system_report=$(gather_system_facts)

# # 2. Мы вызываем функцию сохранения и ПЕРЕДАЕМ ей этот текст в качестве "посылки"
# prompt_persistence "$system_report"

# ```

# В тот момент, когда ты написал `prompt_persistence "$system_report"`, всё содержимое твоего отчета (от HOSTNAME до SPACE_ROOT) упаковалось и «полетело» внутрь функции.

# ---

# ### 2. Что делает `local facts_snapshot="$1"`? (Внутренняя работа)

# Когда выполнение прыгает внутрь функции `prompt_persistence`, Bash автоматически присваивает прилетевшую «посылку» технической переменной `$1`.

# Но работать с переменной, которая называется просто «цифра 1» — неудобно и легко запутаться. Поэтому первой же строчкой мы делаем **переименование**:

# * **`local`**: Мы говорим: «Эта переменная будет существовать только внутри этой функции. Как только функция закончит работу, память очистится». Это защищает скрипт от ошибок.
# * **`facts_snapshot`**: Это новое, понятное имя для нашей «посылки». Мы назвали её «снимок фактов».
# * **`="$1"`**: Мы копируем содержимое технической переменной `$1` в нашу новую переменную.

# ---

# ### 3. Зачем это нужно дальше в коде?

# Теперь, когда у нас есть переменная `facts_snapshot`, мы можем использовать её внутри цикла `while`, когда спрашиваем пользователя: «Сохранить в файл?».

# Посмотри на блок `case` в твоем коде:

# ```bash
# case "$user_choice" in
#     y|yes)
#         # ... создание имени файла ...
#         if echo "$facts_snapshot" > "$report_name"; then
#             echo "Отчёт сохранён"
#         fi

# ```

# **Если бы мы не написали `local facts_snapshot="$1"`:**
# Нам пришлось бы писать `echo "$1" > "$report_name"`. Это работало бы точно так же, но читать такой код через месяц было бы очень сложно — непонятно, что именно лежит в этой «единице».

# ---

# ### Итог: Связующее звено

# 1. **Функция `gather_system_facts**` — генерирует текст.
# 2. **Переменная `system_report**` — временно хранит этот текст в главной части скрипта (`main`).
# 3. **Вызов `prompt_persistence "$system_report"**` — отправляет текст в функцию.
# 4. **Строка `local facts_snapshot="$1"**` — ловит этот текст на входе в функцию и дает ему красивое имя, чтобы потом записать его в файл через `echo`.

# **Простыми словами:** Эта строчка — это **«приемник»**. Она ловит данные, которые ты отправил в функцию из другого места скрипта.








# local facts_snapshot="$1" - А КАК ТАК ПОЛУЧАЕТСЯ ЧТО ДАННЫЕ ПЕРЕДАЮТСЯ В ЭТУ ПЕРЕМЕННУЮ ? 


# Весь секрет в том, что в Linux **функции работают как маленькие самостоятельные программки внутри твоего скрипта.**

# Чтобы данные попали в `facts_snapshot`, они проходят три этапа: **Упаковка**, **Бросок** и **Захват**.

# ---

# ### 1. Упаковка (в главной части скрипта)

# Сначала ты создаешь «посылку». Когда ты пишешь:
# `system_report=$(gather_system_facts)`
# Ты говоришь системе: «Запусти сбор данных, поймай всё, что он напечатает, и засунь это в коробку с надписью `system_report`».

# ### 2. Бросок (вызов функции)

# Теперь тебе нужно передать эту коробку в другую функцию. Ты пишешь:
# `prompt_persistence "$system_report"`

# **Вот здесь происходит магия:**
# Когда Bash видит пробел после названия функции, он понимает, что всё, что идет дальше — это **аргументы** (входящие данные).

# * Он берет содержимое `system_report` и «бросает» его внутрь функции `prompt_persistence`.

# ### 3. Захват (внутри функции) — это и есть твоя строка

# Как только выполнение кода прыгает внутрь `prompt_persistence`, Bash автоматически и без твоего участия раскладывает все «прилетевшие» данные по стандартным ячейкам-номерам:

# * Первый аргумент попадает в переменную **`$1`**
# * Второй (если бы был) в **`$2`**
# * И так далее.

# **И вот тут срабатывает твоя строчка:**
# `local facts_snapshot="$1"`

# 1. **`$1`** — это та самая «техническая ячейка», куда Bash только что положил твой отчет.
# 2. **`facts_snapshot`** — это твоя «именная корзина».
# 3. **`=`** — это команда «переложи содержимое из технической ячейки в мою корзину».
# 4. **`local`** — это уточнение: «эта корзина стоит только в этой комнате (функции), в другие комнаты её не носи».

# ---

# ### Почему нельзя было сразу написать `facts_snapshot`?

# Потому что функция — это «черный ящик». Она не знает, как назывались переменные **снаружи**.

# * Снаружи это мог быть `system_report`.
# * Или `old_data`.
# * Или вообще просто текст в кавычках `"Привет"`.

# Функции всё равно, как это называлось раньше. Она знает только одно: **«Мне что-то прислали, и это что-то лежит в ячейке №1»**.

# ### Наглядная аналогия:

# Представь **почтомат**:

# 1. Ты (главный скрипт) кладешь посылку в **ячейку №1** и закрываешь её.
# 2. Курьер (функция `prompt_persistence`) приходит к почтомату.
# 3. Он не знает, как ты называл эту посылку дома («Старый свитер» или «Подарок»).
# 4. Он просто открывает **ячейку №1** (`$1`) и перекладывает содержимое в свой рюкзак, на котором написано **`facts_snapshot`**.

# **Теперь курьер может ходить с этим рюкзаком по всей функции и использовать данные.**

# Теперь картинка сложилась? Ты буквально «переливаешь» данные из безымянной системной переменной `$1` в свою собственную переменную с понятным именем.






# 9. === БЛОК: ИНТЕРАКТИВНОЕ СОХРАНЕНИЕ В ФАЙЛ ===




prompt_persistence() {
    # local facts_snapshot="$1"
    # Мы принимаем внутрь функции все собранные данные (весь тот текст из cat <<EOF).
    # Теперь они хранятся в переменной facts_snapshot.
    local facts_snapshot="$1"
    
    # while true; do — Это «бесконечный цикл». 
    # Скрипт будет крутиться здесь до тех пор, пока не получит четкий ответ (Да или Нет).
    # Это защита от того, чтобы пользователь не ввел случайную абракадабру.
    while true; do
        # read -rp — Команда для диалога.
        # -r: защита от спецсимволов.
        # -p (prompt): позволяет написать текст вопроса прямо в команде, не используя echo.
        read -rp "Сохранить результат в файл? (Y/N): " user_choice
        
        # user_choice=$(echo ... | tr '[:upper:]' '[:lower:]')
        # Это «уравниватель шансов». Команда tr (translate) превращает все БОЛЬШИЕ буквы в маленькие.
        # Зачем: чтобы скрипту было всё равно, нажал ли пользователь "Y" или "y". 
        # Мы приводим любой ввод к нижнему регистру для легкого сравнения.
        user_choice=$(echo "$user_choice" | tr '[:upper:]' '[:lower:]')
        
        # case — Это «разветвитель». Он проверяет, на какой из вариантов похож ввод пользователя.
        case "$user_choice" in
            # Если ввели y или yes:
            y|yes)
                local timestamp report_name
                # 1. Переменная timestamp (Временная метка). Что в ней хранится: Текущее время в виде строки цифр, разделенных нижним подчеркиванием. Пример значения: 04_01_26_04_30_15
                # 2. Переменная report_name (Имя отчета). Что в ней хранится: Полное имя файла для сохранения, состоящее из временной метки и расширения .status. Пример значения: 04_01_26_04_30_15.status
                
                # Создаем уникальное имя для файла.
                # date +"%d_%m_%y_%H_%M_%S" — берет текущую дату и время до секунды.
                # Получится что-то вроде: 30_12_25_15_30_05.status
                # Так файлы никогда не перезапишут друг друга.
                timestamp=$(date +"%d_%m_%y_%H_%M_%S")
                report_name="${timestamp}.status"
                
                # Проверка успешности создания файла.
                # Мы пытаемся «выстрелить» текстом отчета в файл через знак >.
                # if ... 2>/dev/null — если диск переполнен или нет прав на запись, ошибка уйдет в «черную дыру», а сработает блок else.
                if echo "$facts_snapshot" > "$report_name" 2>/dev/null; then
                    echo -e "
Отчёт сохранён: $report_name"
                    return 0 # Выходим из функции с успехом.
                else
                    echo -e "
Ошибка: не удалось сохранить файл в текущей директории" >&2
                    return 1 # Выходим с кодом ошибки.
                fi
                ;;
            # Если ввели n или no:
            n|no)
                echo -e "
Данные не будут сохранены."
                return 0 # Просто выходим из цикла.
                ;;
            # Если ввели что-то непонятное (любой другой символ — *):
            *)
                echo "Некорректный ввод. Используйте Y или N."
                # Цикл while не прерывается, и вопрос задается снова.
                ;;
        esac
    done
}




















# === 10. БЛОК: ГЛАВНАЯ ФУНКЦИЯ ===


# Точка входа (Entry Point)
# Мы упаковываем основную логику в функцию main, чтобы скрипт был структурированным и предсказуемым.
main() {
    
    # 1. Проверка зависимостей
    # Первым делом вызываем функцию check_dependencies. 
    check_dependencies
    
    # 2. Сбор урожая данных
    # Создаем локальную переменную system_report.
    # system_report=$(gather_system_facts) — запускает ту самую огромную функцию сбора данных.
    # Весь текст, который выдал cat <<EOF внутри gather_system_facts, теперь «законсервирован»  внутри этой переменной. 
    local system_report 
    system_report=$(gather_system_facts)
    
    # 3. Вывод на сцену
    # Печатаем красивую шапку. Опция -e позволяет добавить 
 (перенос строки) для отступа.
    echo -e "
=== СИСТЕМНАЯ СВОДКА ==="
    
    # Выводим содержимое нашей переменной-отчета.
    echo "$system_report"
    echo "======================="
    
    # 4. Сохранение (по желанию пользователя)
    # Передаем наш готовый отчет ($system_report) в функцию prompt_persistence.
    # Там скрипт спросит: «Ну что, сохраняем в файл?» и, если нужно, запишет его на диск.
    prompt_persistence "$system_report"
}

# Магическая строка запуска
# main "$@" — это команда, которая фактически дает старт всему скрипту.
# "$@" — это специальная переменная Bash, которая передает внутрь функции main 
# все аргументы, которые ты мог написать при запуске (например: ./script.sh arg1 arg2).
# Даже если аргументов нет, это «золотой стандарт» написания скриптов.
main "$@"

========================================



=== ФАЙЛ: ./P2/28_12_25_17_14_09.status ===
Путь: /home/s/Рабочий стол/гит/P2/28_12_25_17_14_09.status
Размер: 4,0K
Дата изменения: 2025-12-28 20:14:52.932502239 +0300

СОДЕРЖИМОЕ:
----------------------------------------
HOSTNAME = server
TIMEZONE = Etc/UTC UTC +00
USER = s
OS = Ubuntu 20.04.6 LTS
DATE = 28 Dec 2025 17:14:05
UPTIME = 3 hours, 52 minutes
UPTIME_SEC = 13935 seconds
IP = 192.168.122.195
MASK = 255.255.255.0
GATEWAY = 192.168.122.1
RAM_TOTAL = 3.828 GB
RAM_USED = 0.190 GB
RAM_FREE = 2.972 GB
SPACE_ROOT = 15514.91 MB
SPACE_ROOT_USED = 5818.19 MB
SPACE_ROOT_FREE = 8887.32 MB



========================================



=== ФАЙЛ: ./P2/Time_output.txt ===
Путь: /home/s/Рабочий стол/гит/P2/Time_output.txt
Размер: 4,0K
Дата изменения: 2026-01-01 22:43:13.780711123 +0300

СОДЕРЖИМОЕ:
----------------------------------------




s@Vivo:~$ ip route get 8.8.8.8
8.8.8.8 via 192.168.1.1 dev wlp1s0 src 192.168.1.102 uid 1000 
    cache 


s@Vivo:~$ ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}' 
wlp1s0


s@Vivo:~$ ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}' || echo "eth0"
wlp1s0







s@Vivo:~$ ip -4 addr show dev wlp1s0
2: wlp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    inet 192.168.1.102/24 brd 192.168.1.255 scope global dynamic noprefixroute wlp1s0
       valid_lft 60577sec preferred_lft 60577sec


s@Vivo:~$ ip -4 addr show dev wlp1s0 | awk '/inet/ {print $2; exit}' 
192.168.1.102/24


s@Vivo:~$ ip -4 addr show dev wlp1s0 | awk '/inet/ {print $2; exit}' | cut -d'/' -f1
192.168.1.102
 

 s@Vivo:~$ ip -4 addr show dev wlp1s0 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f2
24




========================================



=== ФАЙЛ: ./Part 4/config.conf ===
Путь: /home/s/Рабочий стол/гит/Part 4/config.conf
Размер: 4,0K
Дата изменения: 2026-01-05 05:36:42.619132433 +0300

СОДЕРЖИМОЕ:
----------------------------------------
column1_background=2
column1_font_color=4
column2_background=5
column2_font_color=1


========================================



=== ФАЙЛ: ./Part 4/info.txt ===
Путь: /home/s/Рабочий стол/гит/Part 4/info.txt
Размер: 4,0K
Дата изменения: 2026-01-05 06:01:53.488616791 +0300

СОДЕРЖИМОЕ:
----------------------------------------
./system_audit.sh

========================================



=== ФАЙЛ: ./Part 4/system_audit.sh ===
Путь: /home/s/Рабочий стол/гит/Part 4/system_audit.sh
Размер: 12K
Дата изменения: 2026-01-05 05:28:34.448298110 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash

set -euo pipefail

trap 'echo -e "

Прервано пользователем."; exit 130' INT TERM

CONFIG_FILE="config.conf"

DEFAULT_COLUMN1_BG=6
DEFAULT_COLUMN1_FG=1
DEFAULT_COLUMN2_BG=2
DEFAULT_COLUMN2_FG=4

get_color() {
    local color_num=$1
    local is_background=$2
    
    case $color_num in
        1)
            [[ $is_background -eq 1 ]] && echo "47" || echo "97"
            ;;
        2)
            [[ $is_background -eq 1 ]] && echo "41" || echo "31"
            ;;
        3)
            [[ $is_background -eq 1 ]] && echo "42" || echo "32"
            ;;
        4)
            [[ $is_background -eq 1 ]] && echo "44" || echo "34"
            ;;
        5)
            [[ $is_background -eq 1 ]] && echo "45" || echo "35"
            ;;
        6)
            [[ $is_background -eq 1 ]] && echo "40" || echo "30"
            ;;
        *)
            echo ""
            ;;
    esac
}

get_color_name() {
    case $1 in
        1) echo "white" ;;
        2) echo "red" ;;
        3) echo "green" ;;
        4) echo "blue" ;;
        5) echo "purple" ;;
        6) echo "black" ;;
        *) echo "unknown" ;;
    esac
}

load_config() {
    local col1_bg=$DEFAULT_COLUMN1_BG
    local col1_fg=$DEFAULT_COLUMN1_FG
    local col2_bg=$DEFAULT_COLUMN2_BG
    local col2_fg=$DEFAULT_COLUMN2_FG
    
    local col1_bg_is_default=1
    local col1_fg_is_default=1
    local col2_bg_is_default=1
    local col2_fg_is_default=1
    
    if [[ -f "$CONFIG_FILE" ]]; then
        while IFS='=' read -r key value; do
            [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
            
            key=$(echo "$key" | tr -d '[:space:]')
            value=$(echo "$value" | tr -d '[:space:]')
            
            if [[ "$value" =~ ^[1-6]$ ]]; then
                case "$key" in
                    column1_background)
                        col1_bg=$value
                        col1_bg_is_default=0
                        ;;
                    column1_font_color)
                        col1_fg=$value
                        col1_fg_is_default=0
                        ;;
                    column2_background)
                        col2_bg=$value
                        col2_bg_is_default=0
                        ;;
                    column2_font_color)
                        col2_fg=$value
                        col2_fg_is_default=0
                        ;;
                esac
            fi
        done < "$CONFIG_FILE"
    fi
    
    if [[ $col1_bg -eq $col1_fg ]]; then
        echo "Ошибка: цвет фона и цвет шрифта для названий не должны совпадать."
        echo "Column 1 background = $col1_bg, Column 1 font color = $col1_fg"
        echo "Пожалуйста, измените конфигурационный файл."
        exit 1
    fi
    
    if [[ $col2_bg -eq $col2_fg ]]; then
        echo "Ошибка: цвет фона и цвет шрифта для значений не должны совпадать."
        echo "Column 2 background = $col2_bg, Column 2 font color = $col2_fg"
        echo "Пожалуйста, измените конфигурационный файл."
        exit 1
    fi
    
    echo "$col1_bg $col1_fg $col2_bg $col2_fg $col1_bg_is_default $col1_fg_is_default $col2_bg_is_default $col2_fg_is_default"
}

check_dependencies() {
    local missing=()
    for cmd in ip awk free df date hostname; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Ошибка: отсутствуют команды: ${missing[*]}" >&2
        exit 1
    fi
}

gather_system_facts() {
    set +e
    
    local bg_name=$1
    local fg_name=$2
    local bg_value=$3
    local fg_value=$4
    
    local color_bg_name color_fg_name color_bg_value color_fg_value
    color_bg_name=$(get_color "$bg_name" 1)
    color_fg_name=$(get_color "$fg_name" 0)
    color_bg_value=$(get_color "$bg_value" 1)
    color_fg_value=$(get_color "$fg_value" 0)
    
    local reset="[0m"
    local name_style="[${color_bg_name};${color_fg_name}m"
    local value_style="[${color_bg_value};${color_fg_value}m"

    local node_name
    node_name=$(hostname -s 2>/dev/null || hostname 2>/dev/null || echo "Unknown")

    local tz_name tz_offset
    if command -v timedatectl &>/dev/null && timedatectl status &>/dev/null; then
        tz_name=$(timedatectl show --value --property=Timezone 2>/dev/null)
        [[ -z "$tz_name" ]] && tz_name="UTC"
        tz_offset=$(date +"%:::z" 2>/dev/null || date +"%z" | sed 's/\([+-][0-9][0-9]\).*/\1/' | sed 's/0\([0-9]\)/\1/')
    else
        tz_name="UTC"
        tz_offset="0"
    fi

    local active_user
    active_user=$(whoami)

    local os_release
    if command -v hostnamectl &>/dev/null && hostnamectl status &>/dev/null; then
        os_release=$(hostnamectl | awk -F': ' '/Operating System/ {print $2; exit}')
    elif command -v lsb_release &>/dev/null; then
        os_release=$(lsb_release -d 2>/dev/null | cut -f2)
    else
        os_release=$(uname -s 2>/dev/null || echo "Unknown")
    fi

    local current_moment
    current_moment=$(LC_TIME=C date +"%d %b %Y %H:%M:%S" | sed 's/^0//')

    local uptime_human uptime_seconds
    if [[ -f /proc/uptime ]]; then
        uptime_seconds=$(awk '{printf "%.0f", $1}' /proc/uptime 2>/dev/null || echo "0")
        
        local days hours mins
        days=$((uptime_seconds / 86400))
        hours=$(((uptime_seconds % 86400) / 3600))
        mins=$(((uptime_seconds % 3600) / 60))
        
        uptime_human=""
        if [[ $days -gt 0 ]]; then
            [[ $days -eq 1 ]] && uptime_human="${days} day" || uptime_human="${days} days"
            uptime_human+=", "
        fi
        [[ $hours -eq 1 ]] && uptime_human+="${hours} hour" || uptime_human+="${hours} hours"
        uptime_human+=", "
        [[ $mins -eq 1 ]] && uptime_human+="${mins} minute" || uptime_human+="${mins} minutes"
    else
        uptime_seconds="N/A"
        uptime_human="N/A"
    fi

    local main_iface
    main_iface=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}' || echo "eth0")

    local machine_ip subnet_mask default_gateway
    machine_ip=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f1)
    [[ -z "$machine_ip" ]] && machine_ip="N/A"

    local cidr_prefix
    cidr_prefix=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f2)
    
    if [[ -n "$cidr_prefix" ]]; then
        subnet_mask=$(awk -v prefix="$cidr_prefix" 'BEGIN {
            if (prefix == "" || prefix < 0 || prefix > 32) {
                print "N/A";
                exit;
            }
            
            mask = 0;
            for (i = 0; i < prefix; i++) {
                mask = mask * 2 + 1;
            }
            for (i = prefix; i < 32; i++) {
                mask = mask * 2;
            }
            
            octet1 = int(mask / 16777216) % 256;
            octet2 = int(mask / 65536) % 256;
            octet3 = int(mask / 256) % 256;
            octet4 = mask % 256;
            
            printf "%d.%d.%d.%d", octet1, octet2, octet3, octet4;
        }')
    else
        subnet_mask="N/A"
    fi

    default_gateway=$(ip route 2>/dev/null | awk '/default/ {print $3; exit}')
    [[ -z "$default_gateway" ]] && default_gateway="N/A"

    local ram_total_gb ram_used_gb ram_free_gb
    if command -v free &>/dev/null; then
        read -r ram_total_gb ram_used_gb ram_free_gb < <(
            LC_ALL=C free -b | awk '/Mem:/ {
                total = $2 / 1024 / 1024 / 1024;
                used  = $3 / 1024 / 1024 / 1024;
                free_m = $4 / 1024 / 1024 / 1024;
                printf "%.3f %.3f %.3f", total, used, free_m
            }'
        )
    else
        ram_total_gb="N/A"
        ram_used_gb="N/A"
        ram_free_gb="N/A"
    fi

    local root_total_mb root_used_mb root_free_mb
    if command -v df &>/dev/null; then
        read -r root_total_mb root_used_mb root_free_mb < <(
            df -B1 / 2>/dev/null | awk 'NR==2 {
                total = $2/1024/1024;
                used = $3/1024/1024;
                free = $4/1024/1024;
                printf "%.2f %.2f %.2f", total, used, free
            }'
        )
    else
        root_total_mb="N/A"
        root_used_mb="N/A"
        root_free_mb="N/A"
    fi

    echo -e "${name_style}HOSTNAME${reset} = ${value_style}$node_name${reset}"
    echo -e "${name_style}TIMEZONE${reset} = ${value_style}$tz_name UTC $tz_offset${reset}"
    echo -e "${name_style}USER${reset} = ${value_style}$active_user${reset}"
    echo -e "${name_style}OS${reset} = ${value_style}$os_release${reset}"
    echo -e "${name_style}DATE${reset} = ${value_style}$current_moment${reset}"
    echo -e "${name_style}UPTIME${reset} = ${value_style}$uptime_human${reset}"
    echo -e "${name_style}UPTIME_SEC${reset} = ${value_style}${uptime_seconds} seconds${reset}"
    echo -e "${name_style}IP${reset} = ${value_style}$machine_ip${reset}"
    echo -e "${name_style}MASK${reset} = ${value_style}$subnet_mask${reset}"
    echo -e "${name_style}GATEWAY${reset} = ${value_style}$default_gateway${reset}"
    echo -e "${name_style}RAM_TOTAL${reset} = ${value_style}${ram_total_gb} GB${reset}"
    echo -e "${name_style}RAM_USED${reset} = ${value_style}${ram_used_gb} GB${reset}"
    echo -e "${name_style}RAM_FREE${reset} = ${value_style}${ram_free_gb} GB${reset}"
    echo -e "${name_style}SPACE_ROOT${reset} = ${value_style}${root_total_mb} MB${reset}"
    echo -e "${name_style}SPACE_ROOT_USED${reset} = ${value_style}${root_used_mb} MB${reset}"
    echo -e "${name_style}SPACE_ROOT_FREE${reset} = ${value_style}${root_free_mb} MB${reset}"
    
    set -e
}

print_color_scheme() {
    local col1_bg=$1
    local col1_fg=$2
    local col2_bg=$3
    local col2_fg=$4
    local col1_bg_is_default=$5
    local col1_fg_is_default=$6
    local col2_bg_is_default=$7
    local col2_fg_is_default=$8
    
    if [[ $col1_bg_is_default -eq 1 ]]; then
        echo "Column 1 background = default ($(get_color_name $col1_bg))"
    else
        echo "Column 1 background = $col1_bg ($(get_color_name $col1_bg))"
    fi
    
    if [[ $col1_fg_is_default -eq 1 ]]; then
        echo "Column 1 font color = default ($(get_color_name $col1_fg))"
    else
        echo "Column 1 font color = $col1_fg ($(get_color_name $col1_fg))"
    fi
    
    if [[ $col2_bg_is_default -eq 1 ]]; then
        echo "Column 2 background = default ($(get_color_name $col2_bg))"
    else
        echo "Column 2 background = $col2_bg ($(get_color_name $col2_bg))"
    fi
    
    if [[ $col2_fg_is_default -eq 1 ]]; then
        echo "Column 2 font color = default ($(get_color_name $col2_fg))"
    else
        echo "Column 2 font color = $col2_fg ($(get_color_name $col2_fg))"
    fi
}

main() {
    check_dependencies
    
    read -r col1_bg col1_fg col2_bg col2_fg col1_bg_is_default col1_fg_is_default col2_bg_is_default col2_fg_is_default < <(load_config)
    
    echo -e "
=== СИСТЕМНАЯ СВОДКА ==="
    gather_system_facts "$col1_bg" "$col1_fg" "$col2_bg" "$col2_fg"
    echo "======================="
    
    echo ""
    print_color_scheme "$col1_bg" "$col1_fg" "$col2_bg" "$col2_fg" "$col1_bg_is_default" "$col1_fg_is_default" "$col2_bg_is_default" "$col2_fg_is_default"
}


main "$@"

========================================



=== ФАЙЛ: ./Part 1/whisper_validator.sh ===
Путь: /home/s/Рабочий стол/гит/Part 1/whisper_validator.sh
Размер: 4,0K
Дата изменения: 2025-12-28 19:30:08.595664980 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash
set -euo pipefail

validate_whisper() {
    local enchanted_word="$1"
    
    if [[ -z "$enchanted_word" ]]; then
        echo "error: заклинание не может быть пустым." >&2
        return 1
    fi
    
    if [[ "$enchanted_word" =~ ^[+-]?[0-9]+(\.[0-9]+)?$ ]]; then
        echo "error: заклинание не должно быть числом." >&2
        return 1
    fi
    
    return 0
}

========================================



=== ФАЙЛ: ./Part 1/echo_spell.sh ===
Путь: /home/s/Рабочий стол/гит/Part 1/echo_spell.sh
Размер: 4,0K
Дата изменения: 2025-12-28 19:30:01.673532989 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/whisper_validator.sh"

if [[ $# -ne 1 ]]; then
    echo "error: требуется ровно одно заклинание." >&2
    exit 1
fi

validate_whisper "$1" || exit 1

echo "$1"

========================================



=== ФАЙЛ: ./Part 1/example.txt ===
Путь: /home/s/Рабочий стол/гит/Part 1/example.txt
Размер: 4,0K
Дата изменения: 2025-12-28 17:13:12.868003059 +0300

СОДЕРЖИМОЕ:
----------------------------------------
chmod +x whisper_validator.sh echo_spell.sh


# Успешный случай
./echo_spell.sh Привет
# → Привет

# Пустой аргумент
./echo_spell.sh ""
# → error: заклинание не может быть пустым.

# Число
./echo_spell.sh 42
# → error: заклинание не должно быть числом.

# Нет аргумента
./echo_spell.sh
# → error: требуется ровно одно заклинание.

# Два аргумента
./echo_spell.sh раз два
# → error: требуется ровно одно заклинание.


========================================



=== ФАЙЛ: ./Part 3/info.txt ===
Путь: /home/s/Рабочий стол/гит/Part 3/info.txt
Размер: 4,0K
Дата изменения: 2026-01-05 04:19:34.407536189 +0300

СОДЕРЖИМОЕ:
----------------------------------------
bash -x 

========================================



=== ФАЙЛ: ./Part 3/system_audit.sh ===
Путь: /home/s/Рабочий стол/гит/Part 3/system_audit.sh
Размер: 12K
Дата изменения: 2026-01-05 05:11:53.617030753 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash

set -euo pipefail

trap 'echo -e "

Прервано пользователем."; exit 130' INT TERM


get_color() {
    local color_num=$1
    local is_background=$2
    
    case $color_num in
        1) 
            [[ $is_background -eq 1 ]] && echo "47" || echo "97"
            ;;
        2) 
            [[ $is_background -eq 1 ]] && echo "41" || echo "31"
            ;;
        3) 
            [[ $is_background -eq 1 ]] && echo "42" || echo "32"
            ;;
        4) 
            [[ $is_background -eq 1 ]] && echo "44" || echo "34"
            ;;
        5) 
            [[ $is_background -eq 1 ]] && echo "45" || echo "35"
            ;;
        6) 
            [[ $is_background -eq 1 ]] && echo "40" || echo "30"
            ;;
        *)
            echo ""
            ;;
    esac
}

validate_parameters() {
    if [[ $# -ne 4 ]]; then
        echo "Ошибка: скрипт должен быть запущен с 4 параметрами."
        echo "Использование: $0 <цвет_фона_названий> <цвет_шрифта_названий> <цвет_фона_значений> <цвет_шрифта_значений>"
        echo "Цвета: 1-white, 2-red, 3-green, 4-blue, 5-purple, 6-black"
        exit 1
    fi
    
    local param1=$1
    local param2=$2
    local param3=$3
    local param4=$4
    
    for param in "$param1" "$param2" "$param3" "$param4"; do
        if ! [[ "$param" =~ ^[1-6]$ ]]; then
            echo "Ошибка: все параметры должны быть числами от 1 до 6."
            echo "Цвета: 1-white, 2-red, 3-green, 4-blue, 5-purple, 6-black"
            exit 1
        fi
    done
    
    if [[ $param1 -eq $param2 ]]; then
        echo "Ошибка: цвет фона и цвет шрифта для названий не должны совпадать."
        echo "Параметр 1 (фон названий) = $param1, Параметр 2 (шрифт названий) = $param2"
        echo "Пожалуйста, запустите скрипт повторно с другими параметрами."
        exit 1
    fi
    
    if [[ $param3 -eq $param4 ]]; then
        echo "Ошибка: цвет фона и цвет шрифта для значений не должны совпадать."
        echo "Параметр 3 (фон значений) = $param3, Параметр 4 (шрифт значений) = $param4"
        echo "Пожалуйста, запустите скрипт повторно с другими параметрами."
        exit 1
    fi
}

check_dependencies() {
    local missing=()
    for cmd in ip awk free df date hostname; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Ошибка: отсутствуют команды: ${missing[*]}" >&2
        exit 1
    fi
}

gather_system_facts() {
    set +e
    
    local bg_name=$1
    local fg_name=$2
    local bg_value=$3
    local fg_value=$4
    
    local color_bg_name color_fg_name color_bg_value color_fg_value
    color_bg_name=$(get_color "$bg_name" 1)
    color_fg_name=$(get_color "$fg_name" 0)
    color_bg_value=$(get_color "$bg_value" 1)
    color_fg_value=$(get_color "$fg_value" 0)
    
    local reset="[0m"
    local name_style="[${color_bg_name};${color_fg_name}m"
    local value_style="[${color_bg_value};${color_fg_value}m"

    local node_name
    node_name=$(hostname -s 2>/dev/null || hostname 2>/dev/null || echo "Unknown")

    local tz_name tz_offset
    if command -v timedatectl &>/dev/null && timedatectl status &>/dev/null; then
        tz_name=$(timedatectl show --value --property=Timezone 2>/dev/null)
        [[ -z "$tz_name" ]] && tz_name="UTC"
        tz_offset=$(date +"%:::z" 2>/dev/null || date +"%z" | sed 's/\([+-][0-9][0-9]\).*/\1/' | sed 's/0\([0-9]\)/\1/')
    else
        tz_name="UTC"
        tz_offset="0"
    fi

    local active_user
    active_user=$(whoami)

    local os_release
    if command -v hostnamectl &>/dev/null && hostnamectl status &>/dev/null; then
        os_release=$(hostnamectl | awk -F': ' '/Operating System/ {print $2; exit}')
    elif command -v lsb_release &>/dev/null; then
        os_release=$(lsb_release -d 2>/dev/null | cut -f2)
    else
        os_release=$(uname -s 2>/dev/null || echo "Unknown")
    fi

    local current_moment
    current_moment=$(LC_TIME=C date +"%d %b %Y %H:%M:%S" | sed 's/^0//')

    local uptime_human uptime_seconds
    if [[ -f /proc/uptime ]]; then
        uptime_seconds=$(awk '{printf "%.0f", $1}' /proc/uptime 2>/dev/null || echo "0")
        
        local days hours mins
        days=$((uptime_seconds / 86400))
        hours=$(((uptime_seconds % 86400) / 3600))
        mins=$(((uptime_seconds % 3600) / 60))
        
        uptime_human=""
        if [[ $days -gt 0 ]]; then
            [[ $days -eq 1 ]] && uptime_human="${days} day" || uptime_human="${days} days"
            uptime_human+=", "
        fi
        [[ $hours -eq 1 ]] && uptime_human+="${hours} hour" || uptime_human+="${hours} hours"
        uptime_human+=", "
        [[ $mins -eq 1 ]] && uptime_human+="${mins} minute" || uptime_human+="${mins} minutes"
    else
        uptime_seconds="N/A"
        uptime_human="N/A"
    fi

    local main_iface
    main_iface=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}' || echo "eth0")

    local machine_ip subnet_mask default_gateway
    machine_ip=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f1)
    [[ -z "$machine_ip" ]] && machine_ip="N/A"

    local cidr_prefix
    cidr_prefix=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f2)
    
    if [[ -n "$cidr_prefix" ]]; then
        subnet_mask=$(awk -v prefix="$cidr_prefix" 'BEGIN {
            if (prefix == "" || prefix < 0 || prefix > 32) {
                print "N/A";
                exit;
            }
            
            mask = 0;
            for (i = 0; i < prefix; i++) {
                mask = mask * 2 + 1;
            }
            for (i = prefix; i < 32; i++) {
                mask = mask * 2;
            }
            
            octet1 = int(mask / 16777216) % 256;
            octet2 = int(mask / 65536) % 256;
            octet3 = int(mask / 256) % 256;
            octet4 = mask % 256;
            
            printf "%d.%d.%d.%d", octet1, octet2, octet3, octet4;
        }')
    else
        subnet_mask="N/A"
    fi

    default_gateway=$(ip route 2>/dev/null | awk '/default/ {print $3; exit}')
    [[ -z "$default_gateway" ]] && default_gateway="N/A"

    local ram_total_gb ram_used_gb ram_free_gb
    if command -v free &>/dev/null; then
        read -r ram_total_gb ram_used_gb ram_free_gb < <(
            LC_ALL=C free -b | awk '/Mem:/ {
                total = $2 / 1024 / 1024 / 1024;
                used  = $3 / 1024 / 1024 / 1024;
                free_m = $4 / 1024 / 1024 / 1024;
                printf "%.3f %.3f %.3f", total, used, free_m
            }'
        )
    else
        ram_total_gb="N/A"
        ram_used_gb="N/A"
        ram_free_gb="N/A"
    fi

    local root_total_mb root_used_mb root_free_mb
    if command -v df &>/dev/null; then
        read -r root_total_mb root_used_mb root_free_mb < <(
            df -B1 / 2>/dev/null | awk 'NR==2 {
                total = $2/1024/1024;
                used = $3/1024/1024;
                free = $4/1024/1024;
                printf "%.2f %.2f %.2f", total, used, free
            }'
        )
    else
        root_total_mb="N/A"
        root_used_mb="N/A"
        root_free_mb="N/A"
    fi

    echo -e "${name_style}HOSTNAME${reset} = ${value_style}$node_name${reset}"
    echo -e "${name_style}TIMEZONE${reset} = ${value_style}$tz_name UTC $tz_offset${reset}"
    echo -e "${name_style}USER${reset} = ${value_style}$active_user${reset}"
    echo -e "${name_style}OS${reset} = ${value_style}$os_release${reset}"
    echo -e "${name_style}DATE${reset} = ${value_style}$current_moment${reset}"
    echo -e "${name_style}UPTIME${reset} = ${value_style}$uptime_human${reset}"
    echo -e "${name_style}UPTIME_SEC${reset} = ${value_style}${uptime_seconds} seconds${reset}"
    echo -e "${name_style}IP${reset} = ${value_style}$machine_ip${reset}"
    echo -e "${name_style}MASK${reset} = ${value_style}$subnet_mask${reset}"
    echo -e "${name_style}GATEWAY${reset} = ${value_style}$default_gateway${reset}"
    echo -e "${name_style}RAM_TOTAL${reset} = ${value_style}${ram_total_gb} GB${reset}"
    echo -e "${name_style}RAM_USED${reset} = ${value_style}${ram_used_gb} GB${reset}"
    echo -e "${name_style}RAM_FREE${reset} = ${value_style}${ram_free_gb} GB${reset}"
    echo -e "${name_style}SPACE_ROOT${reset} = ${value_style}${root_total_mb} MB${reset}"
    echo -e "${name_style}SPACE_ROOT_USED${reset} = ${value_style}${root_used_mb} MB${reset}"
    echo -e "${name_style}SPACE_ROOT_FREE${reset} = ${value_style}${root_free_mb} MB${reset}"
    
    set -e
}

main() {
    validate_parameters "$@"
    check_dependencies
    
    echo -e "
=== СИСТЕМНАЯ СВОДКА ==="
    gather_system_facts "$1" "$2" "$3" "$4"
    echo "======================="
}

main "$@"

========================================



=== ФАЙЛ: ./README.md ===
Путь: /home/s/Рабочий стол/гит/README.md
Размер: 0
Дата изменения: 2026-01-05 06:38:27.109708208 +0300

СОДЕРЖИМОЕ:
----------------------------------------
[Бинарный файл или неподдерживаемый формат]
[Информация о файле: ./README.md: empty]


========================================



=== ФАЙЛ: ./advanced_tree.sh ===
Путь: /home/s/Рабочий стол/гит/advanced_tree.sh
Размер: 4,0K
Дата изменения: 2026-01-05 06:42:28.350159369 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/bin/bash

# Название выходного текстового документа
OUTPUT_FILE="all_contents.txt"

# Очищаем выходной файл или создаем новый
> "$OUTPUT_FILE"

echo "Начинаю сбор содержимого всех файлов..."

# Рекурсивно обходим все файлы в текущей директории и поддиректориях
find . -type f ! -name "$OUTPUT_FILE" | while read -r file; do
    # Добавляем заголовок с путем к файлу
    echo "=== ФАЙЛ: $file ===" >> "$OUTPUT_FILE"
    echo "Путь: $(realpath "$file")" >> "$OUTPUT_FILE"
    echo "Размер: $(du -h "$file" | cut -f1)" >> "$OUTPUT_FILE"
    echo "Дата изменения: $(stat -c %y "$file" 2>/dev/null || date -r "$file")" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    
    # Добавляем содержимое файла
    echo "СОДЕРЖИМОЕ:" >> "$OUTPUT_FILE"
    echo "----------------------------------------" >> "$OUTPUT_FILE"
    
    if [[ -r "$file" ]]; then
        # Пробуем прочитать файл как текстовый
        if file "$file" | grep -q "text"; then
            # Для текстовых файлов
            cat "$file" >> "$OUTPUT_FILE" 2>/dev/null || echo "[Не удалось прочитать файл]" >> "$OUTPUT_FILE"
        else
            # Для бинарных или специальных файлов
            echo "[Бинарный файл или неподдерживаемый формат]" >> "$OUTPUT_FILE"
            echo "[Информация о файле: $(file "$file")]" >> "$OUTPUT_FILE"
        fi
    else
        echo "[Файл недоступен для чтения]" >> "$OUTPUT_FILE"
    fi
    
    echo -e "
" >> "$OUTPUT_FILE"
    echo "========================================" >> "$OUTPUT_FILE"
    echo -e "

" >> "$OUTPUT_FILE"
done

# Подсчитываем статистику
TOTAL_FILES=$(find . -type f ! -name "$OUTPUT_FILE" | wc -l)
TOTAL_DIRS=$(find . -type d | wc -l)
OUTPUT_SIZE=$(du -h "$OUTPUT_FILE" | cut -f1)

# Добавляем сводку в начало файла
SUMMARY="СВОДНАЯ ИНФОРМАЦИЯ
Дата создания: $(date)
Всего директорий: $TOTAL_DIRS
Всего файлов: $TOTAL_FILES
Размер итогового документа: $OUTPUT_SIZE
========================================

"

# Вставляем сводку в начало файла
echo -e "$SUMMARY$(cat "$OUTPUT_FILE")" > "$OUTPUT_FILE.tmp"
mv "$OUTPUT_FILE.tmp" "$OUTPUT_FILE"

echo "Готово!"
echo "Содержимое всех файлов сохранено в: $(realpath "$OUTPUT_FILE")"
echo "Обработано файлов: $TOTAL_FILES"
echo "Размер итогового файла: $OUTPUT_SIZE"


========================================



=== ФАЙЛ: ./Part 5/info.txt ===
Путь: /home/s/Рабочий стол/гит/Part 5/info.txt
Размер: 4,0K
Дата изменения: 2026-01-05 06:06:03.363674863 +0300

СОДЕРЖИМОЕ:
----------------------------------------
# Сделать скрипт исполняемым
chmod +x system_audit.sh 

# Запустить анализ
./system_audit.sh /var/log/
./system_audit.sh ./test_directory/

========================================



=== ФАЙЛ: ./Part 5/system_audit.sh ===
Путь: /home/s/Рабочий стол/гит/Part 5/system_audit.sh
Размер: 8,0K
Дата изменения: 2026-01-05 06:35:04.099969201 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/bin/bash

START_TIME=$(date +%s.%N)

if [ $# -ne 1 ]; then
    echo "Usage: $0 <directory_path>"
    echo "Example: $0 /var/log/"
    exit 1
fi

TARGET_DIR="$1"


if [ ! -d "$TARGET_DIR" ]; then
    echo "Error: Directory '$TARGET_DIR' does not exist"
    exit 1
fi


if [[ ! "$TARGET_DIR" =~ /$ ]]; then
    echo "Error: Directory path must end with '/'"
    echo "Example: $0 ${TARGET_DIR}/"
    exit 1
fi

echo "Analyzing directory: $TARGET_DIR"
echo "Please wait..."
echo


bytes_to_human() {
    local bytes=$1
    local gb=$((bytes / 1024 / 1024 / 1024))
    local mb=$((bytes / 1024 / 1024))
    local kb=$((bytes / 1024))
    
    if [ $gb -gt 0 ]; then
        echo "${gb} GB"
    elif [ $mb -gt 0 ]; then
        echo "${mb} MB"
    elif [ $kb -gt 0 ]; then
        echo "${kb} KB"
    else
        echo "${bytes} bytes"
    fi
}


FOLDER_COUNT=$(find "$TARGET_DIR" -type d 2>/dev/null | wc -l)
echo "Total number of folders (including all nested ones) = $FOLDER_COUNT"


echo "TOP 5 folders of maximum size arranged in descending order (path and size):"
find "$TARGET_DIR" -type d 2>/dev/null | while read -r dir; do
    size_bytes=$(du -sb "$dir" 2>/dev/null | awk '{print $1}')
    echo "$size_bytes|$dir"
done | sort -t'|' -k1 -rn | head -5 | while IFS='|' read -r size_bytes path; do
    size_human=$(bytes_to_human "$size_bytes")

    if [[ ! "$path" =~ /$ ]]; then
        path="${path}/"
    fi
    echo "$path|$size_human"
done | awk -F'|' '{print NR " - " $1 ", " $2}'


TOTAL_FILES=$(find "$TARGET_DIR" -type f 2>/dev/null | wc -l)
echo "Total number of files = $TOTAL_FILES"

echo "Number of:"


CONF_COUNT=$(find "$TARGET_DIR" -type f -name "*.conf" 2>/dev/null | wc -l)
echo "Configuration files (with the .conf extension) = $CONF_COUNT"


TEXT_COUNT=$(find "$TARGET_DIR" -type f -name "*.txt" 2>/dev/null | wc -l)
echo "Text files = $TEXT_COUNT"


EXEC_COUNT=$(find "$TARGET_DIR" -type f -executable 2>/dev/null | wc -l)
echo "Executable files = $EXEC_COUNT"


LOG_COUNT=$(find "$TARGET_DIR" -type f -name "*.log" 2>/dev/null | wc -l)
echo "Log files (with the extension .log) = $LOG_COUNT"


ARCHIVE_COUNT=$(find "$TARGET_DIR" -type f \( -name "*.zip" -o -name "*.tar" -o -name "*.gz" -o -name "*.bz2" -o -name "*.xz" -o -name "*.7z" -o -name "*.rar" -o -name "*.tar.gz" -o -name "*.tgz" \) 2>/dev/null | wc -l)
echo "Archive files = $ARCHIVE_COUNT"


SYMLINK_COUNT=$(find "$TARGET_DIR" -type l 2>/dev/null | wc -l)
echo "Symbolic links = $SYMLINK_COUNT"


echo "TOP 10 files of maximum size arranged in descending order (path, size and type):"
find "$TARGET_DIR" -type f 2>/dev/null -printf "%s|%p
" | sort -t'|' -k1 -rn | head -10 | while IFS='|' read -r size_bytes path; do
    size_human=$(bytes_to_human "$size_bytes")
    

    type="unknown"
    basename_file=$(basename "$path")
    
    case "$path" in
        *.conf) type="conf" ;;
        *.txt) type="text" ;;
        *.log) type="log" ;;
        *.journal) type="journal" ;;
        *.zip|*.tar|*.gz|*.bz2|*.xz|*.7z|*.rar|*.tar.gz|*.tgz) type="archive" ;;
        *.exe) type="exe" ;;
        *.sh|*.bash) type="script" ;;
        *.bin) type="binary" ;;
        *.so|*.so.*) type="library" ;;
        *.deb|*.rpm) type="package" ;;
        *)

            case "$basename_file" in
                syslog*|messages*|daemon*|auth*|kern*|debug*|mail*|user*|cron*) type="log" ;;
            esac
            

            if [ "$type" = "unknown" ] && [ -x "$path" ]; then
                type="executable"
            fi
            ;;
    esac
    
    echo "$path|$size_human|$type"
done | awk -F'|' '{print NR " - " $1 ", " $2 ", " $3}'


echo "TOP 10 executable files of the maximum size arranged in descending order (path, size and MD5 hash of file):"
find "$TARGET_DIR" -type f -executable 2>/dev/null -printf "%s|%p
" | sort -t'|' -k1 -rn | head -10 | while IFS='|' read -r size_bytes path; do
    size_human=$(bytes_to_human "$size_bytes")
    

    if command -v md5sum &> /dev/null; then
        hash=$(md5sum "$path" 2>/dev/null | awk '{print $1}')
    elif command -v md5 &> /dev/null; then
        hash=$(md5 -q "$path" 2>/dev/null)
    else
        hash="unavailable"
    fi
    
    [ -z "$hash" ] && hash="unavailable"
    
    echo "$path|$size_human|$hash"
done | awk -F'|' '{print NR " - " $1 ", " $2 ", " $3}'

END_TIME=$(date +%s.%N)


EXECUTION_TIME=$(echo "$END_TIME - $START_TIME" | bc 2>/dev/null)

if [[ -z "$EXECUTION_TIME" ]] || [[ "$EXECUTION_TIME" =~ ^\. ]]; then
    EXECUTION_TIME="0$EXECUTION_TIME"
fi

echo "Script execution time (in seconds) = $EXECUTION_TIME"

========================================



=== ФАЙЛ: ./P3/system_audit.sh ===
Путь: /home/s/Рабочий стол/гит/P3/system_audit.sh
Размер: 12K
Дата изменения: 2026-01-05 04:58:10.912622629 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash

set -euo pipefail

trap 'echo -e "

Прервано пользователем."; exit 130' INT TERM

# Функция получения цвета по номеру
get_color() {
    local color_num=$1
    local is_background=$2
    
    case $color_num in
        1) # white
            [[ $is_background -eq 1 ]] && echo "47" || echo "97"
            ;;
        2) # red
            [[ $is_background -eq 1 ]] && echo "41" || echo "31"
            ;;
        3) # green
            [[ $is_background -eq 1 ]] && echo "42" || echo "32"
            ;;
        4) # blue
            [[ $is_background -eq 1 ]] && echo "44" || echo "34"
            ;;
        5) # purple
            [[ $is_background -eq 1 ]] && echo "45" || echo "35"
            ;;
        6) # black
            [[ $is_background -eq 1 ]] && echo "40" || echo "30"
            ;;
        *)
            echo ""
            ;;
    esac
}

# Проверка параметров
validate_parameters() {
    if [[ $# -ne 4 ]]; then
        echo "Ошибка: скрипт должен быть запущен с 4 параметрами."
        echo "Использование: $0 <цвет_фона_названий> <цвет_шрифта_названий> <цвет_фона_значений> <цвет_шрифта_значений>"
        echo "Цвета: 1-white, 2-red, 3-green, 4-blue, 5-purple, 6-black"
        exit 1
    fi
    
    local param1=$1
    local param2=$2
    local param3=$3
    local param4=$4
    
    # Проверка диапазона значений
    for param in "$param1" "$param2" "$param3" "$param4"; do
        if ! [[ "$param" =~ ^[1-6]$ ]]; then
            echo "Ошибка: все параметры должны быть числами от 1 до 6."
            echo "Цвета: 1-white, 2-red, 3-green, 4-blue, 5-purple, 6-black"
            exit 1
        fi
    done
    
    # Проверка совпадения цветов в первом столбце (названия)
    if [[ $param1 -eq $param2 ]]; then
        echo "Ошибка: цвет фона и цвет шрифта для названий не должны совпадать."
        echo "Параметр 1 (фон названий) = $param1, Параметр 2 (шрифт названий) = $param2"
        echo "Пожалуйста, запустите скрипт повторно с другими параметрами."
        exit 1
    fi
    
    # Проверка совпадения цветов во втором столбце (значения)
    if [[ $param3 -eq $param4 ]]; then
        echo "Ошибка: цвет фона и цвет шрифта для значений не должны совпадать."
        echo "Параметр 3 (фон значений) = $param3, Параметр 4 (шрифт значений) = $param4"
        echo "Пожалуйста, запустите скрипт повторно с другими параметрами."
        exit 1
    fi
}

check_dependencies() {
    local missing=()
    for cmd in ip awk free df date hostname; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Ошибка: отсутствуют команды: ${missing[*]}" >&2
        exit 1
    fi
}

gather_system_facts() {
    # Временно отключаем строгий режим для сбора данных
    set +e
    
    local bg_name=$1
    local fg_name=$2
    local bg_value=$3
    local fg_value=$4
    
    # Получение ANSI кодов цветов
    local color_bg_name color_fg_name color_bg_value color_fg_value
    color_bg_name=$(get_color "$bg_name" 1)
    color_fg_name=$(get_color "$fg_name" 0)
    color_bg_value=$(get_color "$bg_value" 1)
    color_fg_value=$(get_color "$fg_value" 0)
    
    local reset="[0m"
    local name_style="[${color_bg_name};${color_fg_name}m"
    local value_style="[${color_bg_value};${color_fg_value}m"

    # Сбор данных
    local node_name
    node_name=$(hostname -s 2>/dev/null || hostname 2>/dev/null || echo "Unknown")

    local tz_name tz_offset
    if command -v timedatectl &>/dev/null && timedatectl status &>/dev/null; then
        tz_name=$(timedatectl show --value --property=Timezone 2>/dev/null)
        [[ -z "$tz_name" ]] && tz_name="UTC"
        tz_offset=$(date +"%:::z" 2>/dev/null || date +"%z" | sed 's/\([+-][0-9][0-9]\).*/\1/' | sed 's/0\([0-9]\)/\1/')
    else
        tz_name="UTC"
        tz_offset="0"
    fi

    local active_user
    active_user=$(whoami)

    local os_release
    if command -v hostnamectl &>/dev/null && hostnamectl status &>/dev/null; then
        os_release=$(hostnamectl | awk -F': ' '/Operating System/ {print $2; exit}')
    elif command -v lsb_release &>/dev/null; then
        os_release=$(lsb_release -d 2>/dev/null | cut -f2)
    else
        os_release=$(uname -s 2>/dev/null || echo "Unknown")
    fi

    local current_moment
    current_moment=$(LC_TIME=C date +"%d %b %Y %H:%M:%S" | sed 's/^0//')

    local uptime_human uptime_seconds
    if [[ -f /proc/uptime ]]; then
        uptime_seconds=$(awk '{printf "%.0f", $1}' /proc/uptime 2>/dev/null || echo "0")
        
        local days hours mins
        days=$((uptime_seconds / 86400))
        hours=$(((uptime_seconds % 86400) / 3600))
        mins=$(((uptime_seconds % 3600) / 60))
        
        uptime_human=""
        if [[ $days -gt 0 ]]; then
            [[ $days -eq 1 ]] && uptime_human="${days} day" || uptime_human="${days} days"
            uptime_human+=", "
        fi
        [[ $hours -eq 1 ]] && uptime_human+="${hours} hour" || uptime_human+="${hours} hours"
        uptime_human+=", "
        [[ $mins -eq 1 ]] && uptime_human+="${mins} minute" || uptime_human+="${mins} minutes"
    else
        uptime_seconds="N/A"
        uptime_human="N/A"
    fi

    local main_iface
    main_iface=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}' || echo "eth0")

    local machine_ip subnet_mask default_gateway
    machine_ip=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f1)
    [[ -z "$machine_ip" ]] && machine_ip="N/A"

    local cidr_prefix
    cidr_prefix=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f2)
    
    if [[ -n "$cidr_prefix" ]]; then
        subnet_mask=$(awk -v prefix="$cidr_prefix" 'BEGIN {
            if (prefix == "" || prefix < 0 || prefix > 32) {
                print "N/A";
                exit;
            }
            
            mask = 0;
            for (i = 0; i < prefix; i++) {
                mask = mask * 2 + 1;
            }
            for (i = prefix; i < 32; i++) {
                mask = mask * 2;
            }
            
            octet1 = int(mask / 16777216) % 256;
            octet2 = int(mask / 65536) % 256;
            octet3 = int(mask / 256) % 256;
            octet4 = mask % 256;
            
            printf "%d.%d.%d.%d", octet1, octet2, octet3, octet4;
        }')
    else
        subnet_mask="N/A"
    fi

    default_gateway=$(ip route 2>/dev/null | awk '/default/ {print $3; exit}')
    [[ -z "$default_gateway" ]] && default_gateway="N/A"

    local ram_total_gb ram_used_gb ram_free_gb
    if command -v free &>/dev/null; then
        read -r ram_total_gb ram_used_gb ram_free_gb < <(
            LC_ALL=C free -b | awk '/Mem:/ {
                total = $2 / 1024 / 1024 / 1024;
                used  = $3 / 1024 / 1024 / 1024;
                free_m = $4 / 1024 / 1024 / 1024;
                printf "%.3f %.3f %.3f", total, used, free_m
            }'
        )
    else
        ram_total_gb="N/A"
        ram_used_gb="N/A"
        ram_free_gb="N/A"
    fi

    local root_total_mb root_used_mb root_free_mb
    if command -v df &>/dev/null; then
        read -r root_total_mb root_used_mb root_free_mb < <(
            df -B1 / 2>/dev/null | awk 'NR==2 {
                total = $2/1024/1024;
                used = $3/1024/1024;
                free = $4/1024/1024;
                printf "%.2f %.2f %.2f", total, used, free
            }'
        )
    else
        root_total_mb="N/A"
        root_used_mb="N/A"
        root_free_mb="N/A"
    fi

    # Цветной вывод
    echo -e "${name_style}HOSTNAME${reset} = ${value_style}$node_name${reset}"
    echo -e "${name_style}TIMEZONE${reset} = ${value_style}$tz_name UTC $tz_offset${reset}"
    echo -e "${name_style}USER${reset} = ${value_style}$active_user${reset}"
    echo -e "${name_style}OS${reset} = ${value_style}$os_release${reset}"
    echo -e "${name_style}DATE${reset} = ${value_style}$current_moment${reset}"
    echo -e "${name_style}UPTIME${reset} = ${value_style}$uptime_human${reset}"
    echo -e "${name_style}UPTIME_SEC${reset} = ${value_style}${uptime_seconds} seconds${reset}"
    echo -e "${name_style}IP${reset} = ${value_style}$machine_ip${reset}"
    echo -e "${name_style}MASK${reset} = ${value_style}$subnet_mask${reset}"
    echo -e "${name_style}GATEWAY${reset} = ${value_style}$default_gateway${reset}"
    echo -e "${name_style}RAM_TOTAL${reset} = ${value_style}${ram_total_gb} GB${reset}"
    echo -e "${name_style}RAM_USED${reset} = ${value_style}${ram_used_gb} GB${reset}"
    echo -e "${name_style}RAM_FREE${reset} = ${value_style}${ram_free_gb} GB${reset}"
    echo -e "${name_style}SPACE_ROOT${reset} = ${value_style}${root_total_mb} MB${reset}"
    echo -e "${name_style}SPACE_ROOT_USED${reset} = ${value_style}${root_used_mb} MB${reset}"
    echo -e "${name_style}SPACE_ROOT_FREE${reset} = ${value_style}${root_free_mb} MB${reset}"
    
    # Возвращаем строгий режим
    set -e
}

main() {
    validate_parameters "$@"
    check_dependencies
    
    echo -e "
=== СИСТЕМНАЯ СВОДКА ==="
    gather_system_facts "$1" "$2" "$3" "$4"
    echo "======================="
}

main "$@"

========================================



=== ФАЙЛ: ./Part 2/info.txt ===
Путь: /home/s/Рабочий стол/гит/Part 2/info.txt
Размер: 4,0K
Дата изменения: 2025-12-28 20:03:37.277185642 +0300

СОДЕРЖИМОЕ:
----------------------------------------
Выдайте права на выполнение: chmod +x system_audit.sh
Запустите: ./system_audit.sh


========================================



=== ФАЙЛ: ./Part 2/05_01_26_04_56_10.status ===
Путь: /home/s/Рабочий стол/гит/Part 2/05_01_26_04_56_10.status
Размер: 4,0K
Дата изменения: 2026-01-05 04:56:10.256843474 +0300

СОДЕРЖИМОЕ:
----------------------------------------
HOSTNAME = Vivo
TIMEZONE = Europe/Volgograd UTC +03
USER = s
OS = Ubuntu 24.04.3 LTS
DATE = 5 Jan 2026 04:55:54
UPTIME = 1 day, 15 hours, 35 minutes
UPTIME_SEC = 142517 seconds
IP = 192.168.1.105
MASK = 255.255.255.0
GATEWAY = 192.168.1.1
RAM_TOTAL = 15,029 GB
RAM_USED = 5,285 GB
RAM_FREE = 4,561 GB
SPACE_ROOT = 116114,82 MB
SPACE_ROOT_USED = 22281,00 MB
SPACE_ROOT_FREE = 87890,37 MB


========================================



=== ФАЙЛ: ./Part 2/system_audit.sh ===
Путь: /home/s/Рабочий стол/гит/Part 2/system_audit.sh
Размер: 8,0K
Дата изменения: 2026-01-05 04:55:51.195382472 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash










set -euo pipefail

trap 'echo -e "

Прервано пользователем."; exit 130' INT TERM

check_dependencies() {
    local missing=()
    for cmd in ip awk free df date hostname; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Ошибка: отсутствуют команды: ${missing[*]}" >&2
        exit 1
    fi
}
















gather_system_facts() {



    local node_name
    node_name=$(hostname -s 2>/dev/null || hostname)

    local tz_name tz_offset
    if command -v timedatectl &>/dev/null && timedatectl status &>/dev/null; then
        tz_name=$(timedatectl show --value --property=Timezone 2>/dev/null)
        [[ -z "$tz_name" ]] && tz_name="UTC"
        tz_offset=$(date +"%:::z" 2>/dev/null || date +"%z" | sed 's/\([+-][0-9][0-9]\).*/\1/' | sed 's/0\([0-9]\)/\1/')
    else
        tz_name="UTC"
        tz_offset="0"
    fi








    local active_user
    active_user=$(whoami)

    local os_release
    if command -v hostnamectl &>/dev/null && hostnamectl status &>/dev/null; then
        os_release=$(hostnamectl | awk -F': ' '/Operating System/ {print $2; exit}')
    elif command -v lsb_release &>/dev/null; then
        os_release=$(lsb_release -d 2>/dev/null | cut -f2)
    else
        os_release=$(uname -s 2>/dev/null || echo "Unknown")
    fi


    local current_moment
    current_moment=$(LC_TIME=C date +"%d %b %Y %H:%M:%S" | sed 's/^0//')







    local uptime_human uptime_seconds
    if [[ -f /proc/uptime ]]; then
        uptime_seconds=$(awk '{printf "%.0f", $1}' /proc/uptime)
        
        local days hours mins
        days=$((uptime_seconds / 86400))
        hours=$(((uptime_seconds % 86400) / 3600))
        mins=$(((uptime_seconds % 3600) / 60))
        
        uptime_human=""
        if [[ $days -gt 0 ]]; then
            [[ $days -eq 1 ]] && uptime_human="${days} day" || uptime_human="${days} days"
            uptime_human+=", "
        fi
        [[ $hours -eq 1 ]] && uptime_human+="${hours} hour" || uptime_human+="${hours} hours"
        uptime_human+=", "
        [[ $mins -eq 1 ]] && uptime_human+="${mins} minute" || uptime_human+="${mins} minutes"
    else
        uptime_seconds="N/A"
        uptime_human="N/A"
    fi






















    local main_iface
    main_iface=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}' || echo "eth0")

    local machine_ip subnet_mask default_gateway
    machine_ip=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f1)
    [[ -z "$machine_ip" ]] && machine_ip="N/A"

    local cidr_prefix
    cidr_prefix=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f2)
    
    if [[ -n "$cidr_prefix" ]]; then
        subnet_mask=$(awk -v prefix="$cidr_prefix" 'BEGIN {
            if (prefix == "" || prefix < 0 || prefix > 32) {
                print "N/A";
                exit;
            }
            
            # Расчёт маски через битовые операции
            mask = 0;
            for (i = 0; i < prefix; i++) {
                mask = mask * 2 + 1;
            }
            for (i = prefix; i < 32; i++) {
                mask = mask * 2;
            }
            
            # Извлечение октетов
            octet1 = int(mask / 16777216) % 256;
            octet2 = int(mask / 65536) % 256;
            octet3 = int(mask / 256) % 256;
            octet4 = mask % 256;
            
            printf "%d.%d.%d.%d", octet1, octet2, octet3, octet4;
        }')
    else
        subnet_mask="N/A"
    fi

    default_gateway=$(ip route 2>/dev/null | awk '/default/ {print $3; exit}')
    [[ -z "$default_gateway" ]] && default_gateway="N/A"










    local ram_total_gb ram_used_gb ram_free_gb
    if command -v free &>/dev/null; then
        read -r ram_total_gb ram_used_gb ram_free_gb < <(
            LC_ALL=C free -b | awk '/Mem:/ {
                total = $2 / 1024 / 1024 / 1024;
                used  = $3 / 1024 / 1024 / 1024;
                free_m = $4 / 1024 / 1024 / 1024;
                printf "%.3f %.3f %.3f", total, used, free_m
            }'
        )
    else
        ram_total_gb="N/A"
        ram_used_gb="N/A"
        ram_free_gb="N/A"
    fi












    local root_total_mb root_used_mb root_free_mb
    if command -v df &>/dev/null; then
        read -r root_total_mb root_used_mb root_free_mb < <(
            df -B1 / 2>/dev/null | awk 'NR==2 {
                total = $2/1024/1024;
                used = $3/1024/1024;
                free = $4/1024/1024;
                printf "%.2f %.2f %.2f", total, used, free
            }'
        )
    else
        root_total_mb="N/A"
        root_used_mb="N/A"
        root_free_mb="N/A"
    fi























    cat <<EOF
HOSTNAME = $node_name
TIMEZONE = $tz_name UTC $tz_offset
USER = $active_user
OS = $os_release
DATE = $current_moment
UPTIME = $uptime_human
UPTIME_SEC = ${uptime_seconds} seconds
IP = $machine_ip
MASK = $subnet_mask
GATEWAY = $default_gateway
RAM_TOTAL = ${ram_total_gb} GB
RAM_USED = ${ram_used_gb} GB
RAM_FREE = ${ram_free_gb} GB
SPACE_ROOT = ${root_total_mb} MB
SPACE_ROOT_USED = ${root_used_mb} MB
SPACE_ROOT_FREE = ${root_free_mb} MB
EOF
}















prompt_persistence() {
    local facts_snapshot="$1"
    
    while true; do
        read -rp "Сохранить результат в файл? (Y/N): " user_choice
        
        user_choice=$(echo "$user_choice" | tr '[:upper:]' '[:lower:]')
        
        case "$user_choice" in
            y|yes)
                local timestamp report_name
                timestamp=$(date +"%d_%m_%y_%H_%M_%S")
                report_name="${timestamp}.status"
                
                if echo "$facts_snapshot" > "$report_name" 2>/dev/null; then
                    echo -e "
Отчёт сохранён: $report_name"
                    return 0
                else
                    echo -e "
Ошибка: не удалось сохранить файл в текущей директории" >&2
                    return 1
                fi
                ;;
            n|no)
                echo -e "
Данные не будут сохранены."
                return 0
                ;;
            *)
                echo "Некорректный ввод. Используйте Y или N."
                ;;
        esac
    done
}
























main() {
    check_dependencies
    
    local system_report
    system_report=$(gather_system_facts)
    
    echo -e "
=== СИСТЕМНАЯ СВОДКА ==="
    echo "$system_report"
    echo "======================="
    
    prompt_persistence "$system_report"
}

main "$@"


========================================



=== ФАЙЛ: ./Part 2/28_12_25_17_14_09.status ===
Путь: /home/s/Рабочий стол/гит/Part 2/28_12_25_17_14_09.status
Размер: 4,0K
Дата изменения: 2025-12-28 20:14:52.932502239 +0300

СОДЕРЖИМОЕ:
----------------------------------------
HOSTNAME = server
TIMEZONE = Etc/UTC UTC +00
USER = s
OS = Ubuntu 20.04.6 LTS
DATE = 28 Dec 2025 17:14:05
UPTIME = 3 hours, 52 minutes
UPTIME_SEC = 13935 seconds
IP = 192.168.122.195
MASK = 255.255.255.0
GATEWAY = 192.168.122.1
RAM_TOTAL = 3.828 GB
RAM_USED = 0.190 GB
RAM_FREE = 2.972 GB
SPACE_ROOT = 15514.91 MB
SPACE_ROOT_USED = 5818.19 MB
SPACE_ROOT_FREE = 8887.32 MB



========================================



=== ФАЙЛ: ./P5/system_audit.sh ===
Путь: /home/s/Рабочий стол/гит/P5/system_audit.sh
Размер: 8,0K
Дата изменения: 2026-01-05 06:33:47.167582023 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/bin/bash

# Начало отсчета времени
START_TIME=$(date +%s.%N)

# Проверка параметра
if [ $# -ne 1 ]; then
    echo "Usage: $0 <directory_path>"
    echo "Example: $0 /var/log/"
    exit 1
fi

TARGET_DIR="$1"

# Проверка существования директории
if [ ! -d "$TARGET_DIR" ]; then
    echo "Error: Directory '$TARGET_DIR' does not exist"
    exit 1
fi

# Проверка наличия завершающего слэша
if [[ ! "$TARGET_DIR" =~ /$ ]]; then
    echo "Error: Directory path must end with '/'"
    echo "Example: $0 ${TARGET_DIR}/"
    exit 1
fi

echo "Analyzing directory: $TARGET_DIR"
echo "Please wait..."
echo

# Функция для преобразования байт в человекочитаемый формат (GB, MB, KB)
bytes_to_human() {
    local bytes=$1
    local gb=$((bytes / 1024 / 1024 / 1024))
    local mb=$((bytes / 1024 / 1024))
    local kb=$((bytes / 1024))
    
    if [ $gb -gt 0 ]; then
        echo "${gb} GB"
    elif [ $mb -gt 0 ]; then
        echo "${mb} MB"
    elif [ $kb -gt 0 ]; then
        echo "${kb} KB"
    else
        echo "${bytes} bytes"
    fi
}

# 1. Подсчет папок
FOLDER_COUNT=$(find "$TARGET_DIR" -type d 2>/dev/null | wc -l)
echo "Total number of folders (including all nested ones) = $FOLDER_COUNT"

# 2. TOP 5 папок по размеру (только директории)
echo "TOP 5 folders of maximum size arranged in descending order (path and size):"
find "$TARGET_DIR" -type d 2>/dev/null | while read -r dir; do
    size_bytes=$(du -sb "$dir" 2>/dev/null | awk '{print $1}')
    echo "$size_bytes|$dir"
done | sort -t'|' -k1 -rn | head -5 | while IFS='|' read -r size_bytes path; do
    size_human=$(bytes_to_human "$size_bytes")
    # Добавляем слэш если его нет
    if [[ ! "$path" =~ /$ ]]; then
        path="${path}/"
    fi
    echo "$path|$size_human"
done | awk -F'|' '{print NR " - " $1 ", " $2}'

# 3. Подсчет файлов
TOTAL_FILES=$(find "$TARGET_DIR" -type f 2>/dev/null | wc -l)
echo "Total number of files = $TOTAL_FILES"

# 4. Подсчет файлов по типам
echo "Number of:"

# Конфигурационные файлы
CONF_COUNT=$(find "$TARGET_DIR" -type f -name "*.conf" 2>/dev/null | wc -l)
echo "Configuration files (with the .conf extension) = $CONF_COUNT"

# Текстовые файлы
TEXT_COUNT=$(find "$TARGET_DIR" -type f -name "*.txt" 2>/dev/null | wc -l)
echo "Text files = $TEXT_COUNT"

# Исполняемые файлы
EXEC_COUNT=$(find "$TARGET_DIR" -type f -executable 2>/dev/null | wc -l)
echo "Executable files = $EXEC_COUNT"

# Лог файлы
LOG_COUNT=$(find "$TARGET_DIR" -type f -name "*.log" 2>/dev/null | wc -l)
echo "Log files (with the extension .log) = $LOG_COUNT"

# Архивы
ARCHIVE_COUNT=$(find "$TARGET_DIR" -type f \( -name "*.zip" -o -name "*.tar" -o -name "*.gz" -o -name "*.bz2" -o -name "*.xz" -o -name "*.7z" -o -name "*.rar" -o -name "*.tar.gz" -o -name "*.tgz" \) 2>/dev/null | wc -l)
echo "Archive files = $ARCHIVE_COUNT"

# Символические ссылки
SYMLINK_COUNT=$(find "$TARGET_DIR" -type l 2>/dev/null | wc -l)
echo "Symbolic links = $SYMLINK_COUNT"

# 5. TOP 10 файлов по размеру с улучшенным определением типа
echo "TOP 10 files of maximum size arranged in descending order (path, size and type):"
find "$TARGET_DIR" -type f 2>/dev/null -printf "%s|%p
" | sort -t'|' -k1 -rn | head -10 | while IFS='|' read -r size_bytes path; do
    size_human=$(bytes_to_human "$size_bytes")
    
    # Определение типа файла по расширению и содержимому
    type="unknown"
    basename_file=$(basename "$path")
    
    case "$path" in
        *.conf) type="conf" ;;
        *.txt) type="text" ;;
        *.log) type="log" ;;
        *.journal) type="journal" ;;
        *.zip|*.tar|*.gz|*.bz2|*.xz|*.7z|*.rar|*.tar.gz|*.tgz) type="archive" ;;
        *.exe) type="exe" ;;
        *.sh|*.bash) type="script" ;;
        *.bin) type="binary" ;;
        *.so|*.so.*) type="library" ;;
        *.deb|*.rpm) type="package" ;;
        *)
            # Проверка по имени файла (без расширения)
            case "$basename_file" in
                syslog*|messages*|daemon*|auth*|kern*|debug*|mail*|user*|cron*) type="log" ;;
            esac
            
            # Проверка исполняемости
            if [ "$type" = "unknown" ] && [ -x "$path" ]; then
                type="executable"
            fi
            ;;
    esac
    
    echo "$path|$size_human|$type"
done | awk -F'|' '{print NR " - " $1 ", " $2 ", " $3}'

# 6. TOP 10 исполняемых файлов по размеру с MD5
echo "TOP 10 executable files of the maximum size arranged in descending order (path, size and MD5 hash of file):"
find "$TARGET_DIR" -type f -executable 2>/dev/null -printf "%s|%p
" | sort -t'|' -k1 -rn | head -10 | while IFS='|' read -r size_bytes path; do
    size_human=$(bytes_to_human "$size_bytes")
    
    # Вычисление MD5 хеша
    if command -v md5sum &> /dev/null; then
        hash=$(md5sum "$path" 2>/dev/null | awk '{print $1}')
    elif command -v md5 &> /dev/null; then
        hash=$(md5 -q "$path" 2>/dev/null)
    else
        hash="unavailable"
    fi
    
    [ -z "$hash" ] && hash="unavailable"
    
    echo "$path|$size_human|$hash"
done | awk -F'|' '{print NR " - " $1 ", " $2 ", " $3}'

# Конец отсчета времени
END_TIME=$(date +%s.%N)

# Вычисление времени выполнения с правильным форматированием
EXECUTION_TIME=$(echo "$END_TIME - $START_TIME" | bc 2>/dev/null)

# Проверка на случай если bc вернул пустое значение или начинается с точки
if [[ -z "$EXECUTION_TIME" ]] || [[ "$EXECUTION_TIME" =~ ^\. ]]; then
    EXECUTION_TIME="0$EXECUTION_TIME"
fi

echo "Script execution time (in seconds) = $EXECUTION_TIME"

========================================



=== ФАЙЛ: ./P4/config.conf ===
Путь: /home/s/Рабочий стол/гит/P4/config.conf
Размер: 4,0K
Дата изменения: 2026-01-05 05:37:37.414981993 +0300

СОДЕРЖИМОЕ:
----------------------------------------
column1_background=2
column1_font_color=4
column2_background=5
column2_font_color=1


========================================



=== ФАЙЛ: ./P4/system_audit.sh ===
Путь: /home/s/Рабочий стол/гит/P4/system_audit.sh
Размер: 12K
Дата изменения: 2026-01-05 05:37:29.604095193 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash

set -euo pipefail

trap 'echo -e "

Прервано пользователем."; exit 130' INT TERM

CONFIG_FILE="config.conf"

DEFAULT_COLUMN1_BG=6
DEFAULT_COLUMN1_FG=1
DEFAULT_COLUMN2_BG=2
DEFAULT_COLUMN2_FG=4

get_color() {
    local color_num=$1
    local is_background=$2
    
    case $color_num in
        1)
            [[ $is_background -eq 1 ]] && echo "47" || echo "97"
            ;;
        2)
            [[ $is_background -eq 1 ]] && echo "41" || echo "31"
            ;;
        3)
            [[ $is_background -eq 1 ]] && echo "42" || echo "32"
            ;;
        4)
            [[ $is_background -eq 1 ]] && echo "44" || echo "34"
            ;;
        5)
            [[ $is_background -eq 1 ]] && echo "45" || echo "35"
            ;;
        6)
            [[ $is_background -eq 1 ]] && echo "40" || echo "30"
            ;;
        *)
            echo ""
            ;;
    esac
}

get_color_name() {
    case $1 in
        1) echo "white" ;;
        2) echo "red" ;;
        3) echo "green" ;;
        4) echo "blue" ;;
        5) echo "purple" ;;
        6) echo "black" ;;
        *) echo "unknown" ;;
    esac
}

load_config() {
    local col1_bg=$DEFAULT_COLUMN1_BG
    local col1_fg=$DEFAULT_COLUMN1_FG
    local col2_bg=$DEFAULT_COLUMN2_BG
    local col2_fg=$DEFAULT_COLUMN2_FG
    
    local col1_bg_is_default=1
    local col1_fg_is_default=1
    local col2_bg_is_default=1
    local col2_fg_is_default=1
    
    if [[ -f "$CONFIG_FILE" ]]; then
        while IFS='=' read -r key value; do
            [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
            
            key=$(echo "$key" | tr -d '[:space:]')
            value=$(echo "$value" | tr -d '[:space:]')
            
            if [[ "$value" =~ ^[1-6]$ ]]; then
                case "$key" in
                    column1_background)
                        col1_bg=$value
                        col1_bg_is_default=0
                        ;;
                    column1_font_color)
                        col1_fg=$value
                        col1_fg_is_default=0
                        ;;
                    column2_background)
                        col2_bg=$value
                        col2_bg_is_default=0
                        ;;
                    column2_font_color)
                        col2_fg=$value
                        col2_fg_is_default=0
                        ;;
                esac
            fi
        done < "$CONFIG_FILE"
    fi
    
    if [[ $col1_bg -eq $col1_fg ]]; then
        echo "Ошибка: цвет фона и цвет шрифта для названий не должны совпадать."
        echo "Column 1 background = $col1_bg, Column 1 font color = $col1_fg"
        echo "Пожалуйста, измените конфигурационный файл."
        exit 1
    fi
    
    if [[ $col2_bg -eq $col2_fg ]]; then
        echo "Ошибка: цвет фона и цвет шрифта для значений не должны совпадать."
        echo "Column 2 background = $col2_bg, Column 2 font color = $col2_fg"
        echo "Пожалуйста, измените конфигурационный файл."
        exit 1
    fi
    
    echo "$col1_bg $col1_fg $col2_bg $col2_fg $col1_bg_is_default $col1_fg_is_default $col2_bg_is_default $col2_fg_is_default"
}

check_dependencies() {
    local missing=()
    for cmd in ip awk free df date hostname; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Ошибка: отсутствуют команды: ${missing[*]}" >&2
        exit 1
    fi
}

gather_system_facts() {
    set +e
    
    local bg_name=$1
    local fg_name=$2
    local bg_value=$3
    local fg_value=$4
    
    local color_bg_name color_fg_name color_bg_value color_fg_value
    color_bg_name=$(get_color "$bg_name" 1)
    color_fg_name=$(get_color "$fg_name" 0)
    color_bg_value=$(get_color "$bg_value" 1)
    color_fg_value=$(get_color "$fg_value" 0)
    
    local reset="[0m"
    local name_style="[${color_bg_name};${color_fg_name}m"
    local value_style="[${color_bg_value};${color_fg_value}m"

    local node_name
    node_name=$(hostname -s 2>/dev/null || hostname 2>/dev/null || echo "Unknown")

    local tz_name tz_offset
    if command -v timedatectl &>/dev/null && timedatectl status &>/dev/null; then
        tz_name=$(timedatectl show --value --property=Timezone 2>/dev/null)
        [[ -z "$tz_name" ]] && tz_name="UTC"
        tz_offset=$(date +"%:::z" 2>/dev/null || date +"%z" | sed 's/\([+-][0-9][0-9]\).*/\1/' | sed 's/0\([0-9]\)/\1/')
    else
        tz_name="UTC"
        tz_offset="0"
    fi

    local active_user
    active_user=$(whoami)

    local os_release
    if command -v hostnamectl &>/dev/null && hostnamectl status &>/dev/null; then
        os_release=$(hostnamectl | awk -F': ' '/Operating System/ {print $2; exit}')
    elif command -v lsb_release &>/dev/null; then
        os_release=$(lsb_release -d 2>/dev/null | cut -f2)
    else
        os_release=$(uname -s 2>/dev/null || echo "Unknown")
    fi

    local current_moment
    current_moment=$(LC_TIME=C date +"%d %b %Y %H:%M:%S" | sed 's/^0//')

    local uptime_human uptime_seconds
    if [[ -f /proc/uptime ]]; then
        uptime_seconds=$(awk '{printf "%.0f", $1}' /proc/uptime 2>/dev/null || echo "0")
        
        local days hours mins
        days=$((uptime_seconds / 86400))
        hours=$(((uptime_seconds % 86400) / 3600))
        mins=$(((uptime_seconds % 3600) / 60))
        
        uptime_human=""
        if [[ $days -gt 0 ]]; then
            [[ $days -eq 1 ]] && uptime_human="${days} day" || uptime_human="${days} days"
            uptime_human+=", "
        fi
        [[ $hours -eq 1 ]] && uptime_human+="${hours} hour" || uptime_human+="${hours} hours"
        uptime_human+=", "
        [[ $mins -eq 1 ]] && uptime_human+="${mins} minute" || uptime_human+="${mins} minutes"
    else
        uptime_seconds="N/A"
        uptime_human="N/A"
    fi

    local main_iface
    main_iface=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}' || echo "eth0")

    local machine_ip subnet_mask default_gateway
    machine_ip=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f1)
    [[ -z "$machine_ip" ]] && machine_ip="N/A"

    local cidr_prefix
    cidr_prefix=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f2)
    
    if [[ -n "$cidr_prefix" ]]; then
        subnet_mask=$(awk -v prefix="$cidr_prefix" 'BEGIN {
            if (prefix == "" || prefix < 0 || prefix > 32) {
                print "N/A";
                exit;
            }
            
            mask = 0;
            for (i = 0; i < prefix; i++) {
                mask = mask * 2 + 1;
            }
            for (i = prefix; i < 32; i++) {
                mask = mask * 2;
            }
            
            octet1 = int(mask / 16777216) % 256;
            octet2 = int(mask / 65536) % 256;
            octet3 = int(mask / 256) % 256;
            octet4 = mask % 256;
            
            printf "%d.%d.%d.%d", octet1, octet2, octet3, octet4;
        }')
    else
        subnet_mask="N/A"
    fi

    default_gateway=$(ip route 2>/dev/null | awk '/default/ {print $3; exit}')
    [[ -z "$default_gateway" ]] && default_gateway="N/A"

    local ram_total_gb ram_used_gb ram_free_gb
    if command -v free &>/dev/null; then
        read -r ram_total_gb ram_used_gb ram_free_gb < <(
            LC_ALL=C free -b | awk '/Mem:/ {
                total = $2 / 1024 / 1024 / 1024;
                used  = $3 / 1024 / 1024 / 1024;
                free_m = $4 / 1024 / 1024 / 1024;
                printf "%.3f %.3f %.3f", total, used, free_m
            }'
        )
    else
        ram_total_gb="N/A"
        ram_used_gb="N/A"
        ram_free_gb="N/A"
    fi

    local root_total_mb root_used_mb root_free_mb
    if command -v df &>/dev/null; then
        read -r root_total_mb root_used_mb root_free_mb < <(
            df -B1 / 2>/dev/null | awk 'NR==2 {
                total = $2/1024/1024;
                used = $3/1024/1024;
                free = $4/1024/1024;
                printf "%.2f %.2f %.2f", total, used, free
            }'
        )
    else
        root_total_mb="N/A"
        root_used_mb="N/A"
        root_free_mb="N/A"
    fi

    echo -e "${name_style}HOSTNAME${reset} = ${value_style}$node_name${reset}"
    echo -e "${name_style}TIMEZONE${reset} = ${value_style}$tz_name UTC $tz_offset${reset}"
    echo -e "${name_style}USER${reset} = ${value_style}$active_user${reset}"
    echo -e "${name_style}OS${reset} = ${value_style}$os_release${reset}"
    echo -e "${name_style}DATE${reset} = ${value_style}$current_moment${reset}"
    echo -e "${name_style}UPTIME${reset} = ${value_style}$uptime_human${reset}"
    echo -e "${name_style}UPTIME_SEC${reset} = ${value_style}${uptime_seconds} seconds${reset}"
    echo -e "${name_style}IP${reset} = ${value_style}$machine_ip${reset}"
    echo -e "${name_style}MASK${reset} = ${value_style}$subnet_mask${reset}"
    echo -e "${name_style}GATEWAY${reset} = ${value_style}$default_gateway${reset}"
    echo -e "${name_style}RAM_TOTAL${reset} = ${value_style}${ram_total_gb} GB${reset}"
    echo -e "${name_style}RAM_USED${reset} = ${value_style}${ram_used_gb} GB${reset}"
    echo -e "${name_style}RAM_FREE${reset} = ${value_style}${ram_free_gb} GB${reset}"
    echo -e "${name_style}SPACE_ROOT${reset} = ${value_style}${root_total_mb} MB${reset}"
    echo -e "${name_style}SPACE_ROOT_USED${reset} = ${value_style}${root_used_mb} MB${reset}"
    echo -e "${name_style}SPACE_ROOT_FREE${reset} = ${value_style}${root_free_mb} MB${reset}"
    
    set -e
}

print_color_scheme() {
    local col1_bg=$1
    local col1_fg=$2
    local col2_bg=$3
    local col2_fg=$4
    local col1_bg_is_default=$5
    local col1_fg_is_default=$6
    local col2_bg_is_default=$7
    local col2_fg_is_default=$8
    
    if [[ $col1_bg_is_default -eq 1 ]]; then
        echo "Column 1 background = default ($(get_color_name $col1_bg))"
    else
        echo "Column 1 background = $col1_bg ($(get_color_name $col1_bg))"
    fi
    
    if [[ $col1_fg_is_default -eq 1 ]]; then
        echo "Column 1 font color = default ($(get_color_name $col1_fg))"
    else
        echo "Column 1 font color = $col1_fg ($(get_color_name $col1_fg))"
    fi
    
    if [[ $col2_bg_is_default -eq 1 ]]; then
        echo "Column 2 background = default ($(get_color_name $col2_bg))"
    else
        echo "Column 2 background = $col2_bg ($(get_color_name $col2_bg))"
    fi
    
    if [[ $col2_fg_is_default -eq 1 ]]; then
        echo "Column 2 font color = default ($(get_color_name $col2_fg))"
    else
        echo "Column 2 font color = $col2_fg ($(get_color_name $col2_fg))"
    fi
}

main() {
    check_dependencies
    
    read -r col1_bg col1_fg col2_bg col2_fg col1_bg_is_default col1_fg_is_default col2_bg_is_default col2_fg_is_default < <(load_config)
    
    echo -e "
=== СИСТЕМНАЯ СВОДКА ==="
    gather_system_facts "$col1_bg" "$col1_fg" "$col2_bg" "$col2_fg"
    echo "======================="
    
    echo ""
    print_color_scheme "$col1_bg" "$col1_fg" "$col2_bg" "$col2_fg" "$col1_bg_is_default" "$col1_fg_is_default" "$col2_bg_is_default" "$col2_fg_is_default"
}


main "$@"

========================================



=== ФАЙЛ: ./P1/whisper_validator.sh ===
Путь: /home/s/Рабочий стол/гит/P1/whisper_validator.sh
Размер: 8,0K
Дата изменения: 2025-12-28 19:45:51.449937458 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash
set -euo pipefail

validate_whisper() {
    local enchanted_word="$1"

    # Ключевое слово local. Переменная enchanted_word существует только внутри этой функции. Как только функция закончит работу, переменная «исчезнет». Это признак профессионального и чистого кода.

    # Когда ты вызываешь функцию в основном скрипте вот так: validate_whisper "Привет", Bash берет слово "Привет" и помещает его в локальную переменную функции под номером 1.

    # То есть внутри функции $1 — это то, что ты передал ей в скобках (или рядом с ней) при вызове.

    # Технически, ты мог бы везде внутри функции использовать просто $1. Но мы пишем local enchanted_word="$1" по двум причинам:

    # Читаемость: Когда ты видишь в коде if [[ -z "$enchanted_word" ]], ты сразу понимаешь, что проверяется «заколдованное слово». Если там будет написано просто $1, через 10 минут ты забудешь, что именно в этом «первом аргументе» должно лежать.

    # Удобство: Если логика функции усложнится, работать с именованной переменной гораздо проще.
    

    # Проверка: не пустой
    # -z (сокращение от zero) — возвращает «истину» (true), если строка пустая (её длина равна нулю).
    # Зачем нужны кавычки "$enchanted_word"?
    # Это золотое правило Bash. Если переменная окажется пустой, и ты не поставишь кавычки, Bash увидит это так: if [[ -z ]]. Это синтаксическая ошибка. Кавычки гарантируют, что Bash увидит: if [[ -z "" ]], и поймет, что ты проверяешь именно пустоту.

    if [[ -z "$enchanted_word" ]]; then
        echo "error: заклинание не может быть пустым." >&2
        return 1
    fi
    
    # Проверка: не число
    # Если параметр — число, то должно выводиться сообщение о некорректности ввода.
    # Даже если пользователь введет -5.5, +100 или 42, скрипт это распознает.
    if [[ "$enchanted_word" =~ ^[+-]?[0-9]+(\.[0-9]+)?$ ]]; then
        echo "error: заклинание не должно быть числом." >&2
        return 1
    fi

    # ^ говорит: «Ничего не может стоять ДО этого».
    #     [+-]? — Знак числа.
    #     [+-] означает либо плюс, либо минус.
    #     ? означает «0 или 1 раз». То есть знак может быть, а может и не быть.
    # [0-9]+ — Сами цифры.
    #     [0-9] — любая цифра от 0 до 9.
    #     + — «1 или более раз». (Хотя бы одна цифра обязана быть).
    # (\.[0-9]+)? — Дробная часть.
    #     \. — это обычная точка (обратный слэш нужен, потому что просто точка в Regex означает «любой символ»).
    #     [0-9]+ — цифры после точки.
    #     Вся группа в скобках заканчивается знаком ? — это значит, что точка с цифрами может быть, а может и отсутствовать (если число целое).
    # $ говорит: «Ничего не может стоять ПОСЛЕ этого».
    
    return 0
}

========================================



=== ФАЙЛ: ./P1/echo_spell.sh ===
Путь: /home/s/Рабочий стол/гит/P1/echo_spell.sh
Размер: 8,0K
Дата изменения: 2025-12-28 19:34:32.459850785 +0300

СОДЕРЖИМОЕ:
----------------------------------------
#!/usr/bin/env bash

set -euo pipefail

# set в Bash — это «пульт управления» настройками самого интерпретатора. Она меняет поведение оболочки: определяет, как скрипт должен реагировать на ошибки, пустые переменные или выполнение команд.

# set -e → включить errexit (выход при ошибке),
# set -u — запрет использования неопределённых переменных
# set -o означает: «включи/выключи именованную опцию».
# set -o pipefail → включить режим, при котором пайплайн завершается с ошибкой, если любая команда в нём упала.
# Опции вроде pipefail, nounset, errexit, errtrace — это длинные (именованные) опции, и их можно включить только через -o имя_опции.
# pipefail — аргумент для -o. Когда включена опция pipefail:  Пайплайн завершается с ошибкой, если ЛЮБАЯ команда в нём вернула ошибку (если только все команды не успешны — тогда 0).


# Если коротко: set -e следит за одиночными командами, а set -o pipefail следит за цепочками команд (пайпами).

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"


# Что такое BASH_SOURCE[0] на самом деле? Это массив. Его нулевой элемент ([0]) всегда содержит путь к текущему файлу скрипта.

# Команда dirname (от английского directory name) — это стандартная утилита в Linux/Unix, которая выполняет одну простую задачу: она отрезает имя файла от пути, оставляя только путь к папке (директории), в которой этот файл находится.

# Когда ты запускаешь скрипт именно командой `./echo_spell.sh Привет`, находясь **в той же папке**, где лежат файлы, вот что происходит пошагово внутри этой «магической» строки:

# ### 1. Переменная `${BASH_SOURCE[0]}`

# Bash видит, как именно ты вызвал скрипт. Раз ты написал `./echo_spell.sh`, то внутри переменной будет:

# * **Значение:** `./echo_spell.sh`

# ### 2. Команда `dirname`

# Она берет строку `./echo_spell.sh` и отрезает имя файла. Остается только путь к папке:

# * **Результат:** `.` (точка в Linux означает «текущая папка»)

# ### 3. Команда `cd "."`

# Теперь выполняется команда перехода в эту папку. Поскольку точка — это «здесь же», Bash просто подтверждает свое местоположение.

# ### 4. Команда `pwd`

# Это ключевой момент. Команда `pwd` (Print Working Directory) игнорирует относительные пути (точки) и выдает **полный «физический» адрес** от корня диска.

# * Например, если твоя папка на самом деле лежит в документах, `pwd` вернет:
# `/home/user/projects/magic_script`

# ### 5. Присваивание `SCRIPT_DIR`

# Весь этот вычисленный длинный путь записывается в переменную. Теперь переменная `SCRIPT_DIR` равна не просто точке `.`, а полноценному адресу: `/home/user/projects/magic_script`.

# ---

# ### Почему это сработало в твоем случае?

# Когда дальше по коду идет строка:
# `source "$SCRIPT_DIR/whisper_validator.sh"`

# Bash превращает её в:
# `source "/home/user/projects/magic_script/whisper_validator.sh"`

# **В чем магия:**
# Даже если ты выйдешь из этой папки (например, напишешь `cd ..`) и попробуешь запустить скрипт издалека:
# `./magic_script/echo_spell.sh Привет`

# Скрипт **все равно найдет** файл валидатора, потому что `SCRIPT_DIR` вычислит правильный путь `/home/user/projects/magic_script`, а не будет искать его в твоей текущей папке.

# ---

# **Что дальше?**
# Теперь, когда `SCRIPT_DIR` определен, скрипт переходит к выполнению `validate_whisper "$@"`. Хочешь разберем, как именно символ `"$@"` передает твое слово "Привет" внутрь функции валидации?


source "$SCRIPT_DIR/whisper_validator.sh"

#Команда source (в Bash её также можно заменить простым символом точки .) — это команда, которая заставляет текущую оболочку (shell) прочитать указанный файл и выполнить содержащийся в нем код внутри текущего процесса.

# Главный скрипт «импортирует» функцию validate_whisper.

# Сначала Bash берет переменную $SCRIPT_DIR, которую мы вычислили строчкой выше (например, /home/s/.../P1), и подставляет её в строку. Команда превращается из: source "$SCRIPT_DIR/whisper_validator.sh" в: source "/home/s/Рабочий стол/.../P1/whisper_validator.sh"


# Проверка количества аргументов
if [[ $# -ne 1 ]]; then # Если количество аргументов НЕ равно 1...
    echo "error: требуется ровно одно заклинание." >&2   # Перенаправление в поток ошибок >&2
    exit 1
fi

# $# — это специальная встроенная переменная в Bash, которая работает как счётчик. Она показывает, сколько аргументов (слов) ты передал скрипту при его запуске.

# Запуск с одним словом: ./echo_spell.sh Привет В этом случае $# = 1 (Аргумент $1 — это "Привет")

# Валидация содержимого
validate_whisper "$1" || exit 1

# 1. validate_whispe. Это та самая функция, которую ты «импортировал» из файла whisper_validator.sh с помощью команды source. Теперь она работает как обычная команда Bash.
# Если ты запустил ./echo_spell.sh Привет, то в "$1" подставится слово Привет.
# Кавычки здесь критически важны: они защищают строку, если в ней вдруг окажутся пробелы или спецсимволы.

# Эта команда выполняется только в том случае, если валидация провалилась. Она мгновенно завершает работу всего скрипта с кодом ошибки 1.

echo "$1" # выводит на экран то самое «заклинание» (первый аргумент), которое ты передал при запуске.


========================================



=== ФАЙЛ: ./P1/example.txt ===
Путь: /home/s/Рабочий стол/гит/P1/example.txt
Размер: 4,0K
Дата изменения: 2025-12-28 19:29:43.782355798 +0300

СОДЕРЖИМОЕ:
----------------------------------------
chmod +x whisper_validator.sh echo_spell.sh


# Успешный случай
./echo_spell.sh Привет
# → Привет

# Пустой аргумент
./echo_spell.sh ""
# → error: заклинание не может быть пустым.

# Число
./echo_spell.sh 42
# → error: заклинание не должно быть числом.

# Нет аргумента
./echo_spell.sh
# → error: требуется ровно одно заклинание.

# Два аргумента
./echo_spell.sh раз два
# → error: требуется ровно одно заклинание.


========================================
