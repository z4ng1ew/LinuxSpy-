#!/usr/bin/env bash

# === БЛОК 1: ДИАЛОГ С ПОЛЬЗОВАТЕЛЕМ ===
prompt_persistence() {
    # ПРИЕМ ДАННЫХ:
    # $1 — это тот самый длинный текст отчета, который мы передали из main.sh.
    # Мы кладем его в локальную переменную facts_snapshot ("снимок фактов").
    local facts_snapshot="$1"
    
    # Бесконечный цикл, пока не получим внятный ответ.
    while true; do
        # read -p: Выводит вопрос и ждет ввода. -r отключает спецсимволы.
        read -rp "Сохранить результат в файл? (Y/N): " user_choice
        
        # НОРМАЛИЗАЦИЯ:
        # tr '[:upper:]' '[:lower:]': Превращает "Yes", "YES", "Y" в маленькие "yes", "y".
        user_choice=$(echo "$user_choice" | tr '[:upper:]' '[:lower:]')
        
        # CASE — переключатель вариантов.
        case "$user_choice" in
            y|yes)
                # === СОХРАНЕНИЕ ===
                local timestamp report_name
                # Генерируем имя файла с датой (чтобы не перезатирать старые).
                timestamp=$(date +"%d_%m_%y_%H_%M_%S")
                report_name="${timestamp}.status"
                
                # Пытаемся записать текст в файл.
                # > — оператор записи (создает файл или перезаписывает).
                if echo "$facts_snapshot" > "$report_name" 2>/dev/null; then
                    echo -e "\nОтчёт сохранён: $report_name"
                    return 0 # Успех (код 0).
                else
                    echo -e "\nОшибка: не удалось сохранить файл в текущей директории" >&2
                    return 1 # Ошибка (код 1).
                fi
                ;;
            n|no)
                echo -e "\nДанные не будут сохранены."
                return 0 # Просто выходим.
                ;;
            *)
                # ЗВЕЗДОЧКА (*): Означает "всё остальное". Если пользователь ввел чушь.
                echo "Некорректный ввод. Используйте Y или N."
                ;;
        esac
    done
}