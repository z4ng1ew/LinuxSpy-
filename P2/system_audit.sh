#!/usr/bin/env bash


# СОДЕРЖАНИЕ:


# 1. === БЛОК: НАСТРОЙКА И КОНТРОЛЬ ОКРУЖЕНИЯ ===
# 2. === БЛОК: (timedatectl) ИДЕНТИФИКАЦИЯ ЧАСОВОГО ПОЯСА, ВРЕМЕНИ, СМЕЩЕНИЯ (TIMEZONE) И HOSTNAME (сетевое имя) ===
# 3. === БЛОК: (hostnamectl)  ИДЕНТИФИКАЦИЯ АКТИВНОГО ПОЛЬЗОВАТЕЛЯ И СИСТЕМЫ (USER, OS) ===
# 4. === БЛОК: UPTIME, UPTIME_SEC ===
# 5. === БЛОК: IP, MASK & GATEWAY ===
# 6. === БЛОК 5: RAM_TOTAL, RAM_USED & RAM_FREE ===
# 7. === БЛОК 6: SPACE_ROOT, SPACE_ROOT_USED & SPACE_ROOT_FREE ===
# 8. === БЛОК: ФОРМИРОВАНИЕ ИТОГОВОГО ОТЧЕТА ===
# 9. === БЛОК: ИНТЕРАКТИВНОЕ СОХРАНЕНИЕ В ФАЙЛ ===
# === 10. БЛОК: ГЛАВНАЯ ФУНКЦИЯ ===













# 1. === БЛОК: НАСТРОЙКА И КОНТРОЛЬ ОКРУЖЕНИЯ ===

set -euo pipefail

# Обработка прерывания (Ctrl+C)
trap 'echo -e "\n\nПрервано пользователем."; exit 130' INT TERM


# Команда trap — это встроенный инструмент Bash, который позволяет скрипту «перехватывать» сигналы от операционной системы и выполнять в ответ заданные действия (функции или команды).

# Простыми словами: это обработчик событий. Вы говорите скрипту: «Если произойдет событие Х, сделай действие Y вместо стандартного поведения».

# Опция -e заставляет команду echo интерпретировать (распознавать) экранированные символы с обратным слешем.

# В операционных системах Linux и Unix принято, что если процесс завершился из-за прерывания сигналом, его код выхода должен быть равен 128 + номер сигнала.

#     Сигнал SIGINT (тот самый Ctrl+C) имеет порядковый номер 2.  128+2=130.

# INT и TERM — это сокращенные названия стандартных сигналов, которые операционная система (ядро Linux) посылает программе, чтобы заставить её завершиться. INT (SIGINT)

#     Полное название: SIGINT (Signal Interrupt).

#     Как вызывается: Проще всего — нажатием клавиш Ctrl + C в терминале.

#     Смысл: Это просьба пользователя: «Прерви то, что ты делаешь прямо сейчас, и закройся».


# Почему в скрипте они указаны вместе? В строке trap '...' INT TERM автор объединил их, потому что реакция на них должна быть одинаковой: Независимо от того, нажал ли пользователь Ctrl+C (INT) или систему попросили выключить этот процесс через команду kill (TERM), скрипт должен:    Вывести сообщение «Прервано пользователем».  Завершиться с кодом 130.

# Проверка наличия необходимых команд
check_dependencies() {
    local missing=()
    for cmd in ip awk free df date hostname; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done
    
    # Этот блок кода — финальный вердикт. После того как цикл проверил все команды, этот фрагмент решает: можно ли запускать скрипт дальше или нужно аварийно остановиться.
    # missing — имя нашего массива, куда мы записывали отсутствующие команды.
    #[@] — говорит Bash: «смотри на все элементы массива».
    # # - (в самом начале) — это ключ, который приказывает: «не выводи сами элементы, а просто посчитай их количество».

    if [[ ${#missing[@]} -gt 0 ]]; then # -gt 0 — Сравнение. В Bash для сравнения чисел вместо знака > используются буквы:
        echo "Ошибка: отсутствуют команды: ${missing[*]}" >&2
        exit 1
    fi
}

# Создается локальный пустой массив с именем missing («пропущенные»). В него мы будем записывать названия программ, которых не оказалось на компьютере.

# for cmd - Здесь мы создаем временную переменную с именем cmd (сокращение от command). В эту переменную на каждом шаге цикла будет подставляться одно новое значение из списка.

# Скрипт видит здесь 6 отдельных слов:

#     ip (настройка сети)

#     awk (обработка текста)

#     free (информация о памяти)

#     df (информация о диске)

#     date (время и дата)

#     hostname (имя компьютера)

# 3. ; do

# Это техническое слово-разделитель. Оно говорит Bash: «Список закончен, теперь начинай выполнять команды, которые стоят внутри цикла».

# command -v — это стандартный и самый быстрый способ узнать, установлена ли программа в системе.



# &>/dev/null (Скрытие мусора)- Эта конструкция — «черная дыра» для вывода. Буква & означает «все потоки» (и обычные сообщения, и сообщения об ошибках). >/dev/null — это специальный виртуальный файл в Linux, который просто поглощает любые данные, направленные в него.  Зачем это здесь? Нам не нужно, чтобы при проверке экран засорялся путями типа /bin/ip. Нам важен только результат: «да» или «нет».

# Если команды нет (ошибка) — выполняется missing+=("$cmd"), которая добавляет название этой команды в список отсутствующих.

# Итог всей строки: «Проверь, есть ли команда в системе. Сделай это молча. Если её нет — запиши её имя в список отсутствующих».








































# Сбор системной информации
gather_system_facts() {

# 2. === БЛОК: (timedatectl) ИДЕНТИФИКАЦИЯ ЧАСОВОГО ПОЯСА, ВРЕМЕНИ, СМЕЩЕНИЯ (TIMEZONE) И HOSTNAME (сетевое имя) ===


    # Имя хоста
    local node_name
    node_name=$(hostname -s 2>/dev/null || hostname)

    # Команда hostname выводит полное доменное имя компьютера. Опция -s (или --short) заставляет её выводить только короткое имя без домена.
    # 2>/dev/null - Это уже знакомая нам «заглушка». Она перенаправляет поток ошибок (канал 2) в «пустоту». Таким образом, если команда hostname выдаст ошибку (что маловероятно, но всё же), сообщение об ошибке не будет показано пользователю.

    # || hostname (Логическое ИЛИ) - Это запасной план.  Если первая часть (hostname -s) по какой-то причине завершилась с ошибкой (например, команда не поняла флаг -s), то благодаря оператору || выполнится вторая часть — просто команда hostname без флагов.



    # Временная зона с расчётом UTC-смещения
    local tz_name tz_offset # здесь объявляются сразу две переменные — tz_name (для названия временной зоны, например Europe/Moscow) и tz_offset (для числового смещения, например +3).

    # command -v timedatectl &>/dev/null - Проверка наличия команды timedatectl в системе. 
    # timedatectl status &>/dev/null - Это проверка на работоспособность.  Бывает так, что программа timedatectl в системе есть, но она не работает. Например, если система запущена без systemd (которым управляет эта утилита), команда выдаст ошибку: «Failed to create bus connection».Вызывая status, мы убеждаемся, что утилита не просто «висит мертвым грузом», а способна отдавать данные.


    if command -v timedatectl &>/dev/null && timedatectl status &>/dev/null; then
        tz_name=$(timedatectl show --value --property=Timezone 2>/dev/null)

        # --property=Timezone: мы просим показать только одну конкретную настройку — часовой пояс.

        [[ -z "$tz_name" ]] && tz_name="UTC"  # «Если переменная tz_name оказалась пустой, то запиши в неё текст "UTC"».

        # UTC в этой строчке — это «безопасная гавань». Если скрипт не смог определить, где находится сервер (в Токио или Париже), он говорит: «Окей, тогда будем считать по мировому стандарту». UTC — это «нулевой меридиан» для времени. Все остальные часовые пояса считаются как смещение от него (например, UTC+3 или UTC-5). Если мы не знаем локальное время сервера, безопаснее всего показать время в «нулевой» зоне, так как любой администратор в мире поймет, как соотнести его со своим временем.


        # Попытка получить смещение в формате -5 или +3
        tz_offset=$(date +"%:::z" 2>/dev/null || date +"%z" | sed 's/\([+-][0-9][0-9]\).*/\1/' | sed 's/0\([0-9]\)/\1/')
        # 1. План А: Современный способ. date +"%:::z" 2>/dev/null. Команда date с флагом +"%:::z" (три двоеточия) в современных системах выводит смещение в самом простом виде: например, +03 или -05.

        # План Б: Старый способ + «хирургия» текста. date +"%z" | sed 's/\([+-][0-9][0-9]\).*/\1/' | sed 's/0\([0-9]\)/\1/'
        # Тут происходит цепочка превращений:
        # date +"%z": Выдает стандартное смещение из 4 цифр, например +0300.
        # Первый sed: Обрезает лишние нули в конце.
        #   Было: +0300 -> Стало: +03.
        #   Регулярное выражение ищет плюс/минус и две цифры, а всё остальное отбрасывает.
        #Второй sed: Убирает ведущий ноль, если он есть.
        #   Было: +03 -> Стало: +3.
        #   Это делается для красоты, чтобы в отчете не было лишних цифр.


    else
        tz_name="UTC"
        tz_offset="0"
    fi

    # tz_name="UTC": Мы принудительно устанавливаем название зоны как «Всемирное координированное время». Это самый безопасный стандарт (как мы обсуждали ранее).
    # tz_offset="0": Поскольку UTC — это нулевой меридиан, смещение от него равно нулю.
    # Это защита от сбоя. Автор скрипта гарантирует, что переменные tz_name и tz_offset будут определены в любом случае, на любом «железе».




































# 3. === БЛОК: (hostnamectl)  ИДЕНТИФИКАЦИЯ АКТИВНОГО ПОЛЬЗОВАТЕЛЯ И СИСТЕМЫ (USER, OS) ===


    # Пользователь
    local active_user
    active_user=$(whoami)

    # Операционная система
    local os_release

    # Команда command с опцией -v — это встроенный инструмент Bash, который используется для проверки существования программы в системе и определения пути к ней.

    # -v (verbose/value): Эта опция заставляет команду не запускать программу, а просто вывести путь к её исполняемому файлу. Если программа установлена, команда вернет её полный путь (например, /usr/bin/ls). Если программа не найдена, команда вернет ошибку.

    # hostnamectl  — это основной способ в современных Linux-системах (использующих systemd) получить краткую сводку о конфигурации системы.

    # status — это подкоманда (аргумент), которая приказывает утилите показать текущее состояние системы.

    # МЕТОД 1: Современный (systemd). Самый информативный.
    # Проверяем: 1) есть ли сама утилита hostnamectl, 2) может ли она выдать статус (работает ли dbus)

    # D-Bus (Desktop Bus) — это «почтовая служба» или «шина сообщений» внутри Linux. Она позволяет разным программам в системе общаться друг с другом, даже если они написаны на разных языках программирования и работают как абсолютно независимые процессы.

    if command -v hostnamectl &>/dev/null && hostnamectl status &>/dev/null; then
        # Берем вывод hostnamectl, ищем строку "Operating System", 
        # делим её по разделителю ": " и забираем вторую часть (само название ОС)
        os_release=$(hostnamectl | awk -F': ' '/Operating System/ {print $2; exit}')
          # AWK — это не просто команда, а целый язык программирования, специально созданный для обработки текста, структурированного в виде колонок или строк (таблиц, логов, конфигов). Его название — это аббревиатура из первых букв фамилий создателей: Aho, Weinberger, Kernighan.

          # Флаг -F (Field Separator) указывает awk, какой символ считать «границей» между колонками.    В выводе hostnamectl строки выглядят так: Operating System: Ubuntu 22.04.    Мы говорим: «Разделителем является двоеточие с последующим пробелом (: )».    Теперь для awk всё, что до двоеточия — это поле №1, а всё, что после — поле №2.

          # {print $2; exit} (Действие) - Это то, что нужно сделать, когда строка найдена:    print $2: Напечатать содержимое второго поля (то есть всё, что идет после : ).    ; exit: Это очень важная деталь. Как только мы нашли нужную строку и напечатали её, мы немедленно прекращаем работу. Нам не нужно читать оставшиеся 10 строк вывода команды — это экономит время.

    # МЕТОД 2: Традиционный (LSB - Linux Standard Base).
    # Если hostnamectl недоступен, проверяем наличие утилиты lsb_release (часто есть в Ubuntu/Debian)
    # lsb_release — это стандартная системная утилита в Linux, которая выводит специфическую информацию о вашем дистрибутиве (название, версию, кодовое имя).

    elif command -v lsb_release &>/dev/null; then
    # Вызываем описание системы (-d), скрываем ошибки и вырезаем только название (второе поле) - Description
    # Здесь два поля:        Поле 1: Description:        Поле 2: Ubuntu 22.04.3 LTS  . Команда cut -f2 просто выбрасывает первое поле и оставляет только второе. В итоге в переменную os_release попадает чистое название системы без лишних слов.
        os_release=$(lsb_release -d 2>/dev/null | cut -f2)
    else
    # МЕТОД 3: Универсальный (POSIX).
    # Если всё вышеперечисленное не сработало (например, в минимальном Docker-контейнере)
    # uname -Она запрашивает у ядра операционной системы данные о железе и программной платформе. Эта команда есть абсолютно в любой Linux-системе, даже в самой крошечной (например, в роутерах или умных чайниках), потому что она является частью стандарта POSIX.

    # Опция -s (kernel-sysname) - Эта опция приказывает команде вывести только название ядра.

    # Если даже uname упал, пишем "Unknown", чтобы переменная не осталась пустой.
        os_release=$(uname -s 2>/dev/null || echo "Unknown")
    fi

    # Текущее время в требуемом формате (портабельная версия)
    local current_moment
    current_moment=$(LC_TIME=C date +"%d %b %Y %H:%M:%S" | sed 's/^0//')
    # Команда date выводит системное время, а знак + указывает, что мы хотим использовать собственный формат вывода. # 30 дек 2025 12:09:50

    # Здесь результат работы date передается «по конвейеру» команде sed, которая занимается поиском и заменой текста.

    # s — Сокращение от substitute (заменить).

    # / — Разделители частей команды.

    # ^0 — Это регулярное выражение.

    #     Символ ^ означает «начало строки».

    #     Цифра 0 — это то, что мы ищем.

    #     Вместе ^0 значит: «найди ноль, только если он стоит в самом начале текста».

    # // — Между этими слешами пусто. Это значит «заменить на ничто» (то есть просто удалить).






























# 4. === БЛОК: UPTIME, UPTIME_SEC ===



    # Время работы системы

    # Этот блок кода очень гибкий. Благодаря проверкам на «единственное/множественное число» и условию if [[ $days -gt 0 ]], вывод меняется в зависимости от того, как долго работает сервер.

    # Объявляем локальные переменные, которые будут видны только внутри этой функции
    # uptime_human — для итоговой строки (напр., "2 days, 3 hours")
    # uptime_seconds — для хранения общего количества секунд работы
    local uptime_human uptime_seconds


    # Проверяем, существует ли файл /proc/uptime
    # Это виртуальный файл в Linux, который содержит данные о времени работы ядра
    if [[ -f /proc/uptime ]]; then

        # Извлекаем количество секунд из файла и округляем их
        # $(...) — подстановка результата команды в переменную
        # awk '{printf "%.0f", $1}' — берет первое число из файла и округляет до целого
        uptime_seconds=$(awk '{printf "%.0f", $1}' /proc/uptime)
      
        
        # Расчёт времени работы вручную для портабельности. Объявляем локальные переменные для хранения результатов деления
        local days hours mins


        # 1. Считаем полные дни
        # В одном дне 86400 секунд (24 * 60 * 60).
        # Целочисленное деление отсекает остаток.
        days=$((uptime_seconds / 86400))
        
        # 2. Считаем оставшиеся часы
        # % 86400 — находим остаток секунд, которые не "вместились" в полные дни.
        # Делим этот остаток на 3600 (секунд в 1 часе).
        hours=$(((uptime_seconds % 86400) / 3600))

        
        # 3. Считаем оставшиеся минуты
        # % 3600 — находим остаток секунд, которые не "вместились" в полные часы.
        # Делим на 60 (секунд в 1 минуте).
        mins=$(((uptime_seconds % 3600) / 60))


        # 1. Сначала создаем пустую переменную для "человеческого" аптайма. (Human-readable uptime) — это способ отображения времени работы системы не в виде огромного числа секунд, а в формате, который понятен любому человеку с первого взгляда.
        
        uptime_human=""

        # 2. Проверяем, есть ли хотя бы один полный день работы
        if [[ $days -gt 0 ]]; then

            # 3. Грамматическая проверка (единственное или множественное число):
            # Если день ровно 1 ($days -eq 1), пишем "1 day"
            # В противном случае (||) пишем, например, "5 days"
            [[ $days -eq 1 ]] && uptime_human="${days} day" || uptime_human="${days} days"

            # Добавляем запятую после дней (если они были добавлены ранее),
            # так как дальше в строку добавятся часы и минуты
            uptime_human+=", "
        fi
        # 1. Считаем и форматируем ЧАСЫ
        # Если час ровно 1 ($hours -eq 1), добавляем строку "1 hour"
        # В противном случае (||) добавляем, например, "5 hours" // Если часов не 1 (например, 0 или 5), выполнится часть после ||: 5 hours.
        [[ $hours -eq 1 ]] && uptime_human+="${hours} hour" || uptime_human+="${hours} hours"
        uptime_human+=", "
        [[ $mins -eq 1 ]] && uptime_human+="${mins} minute" || uptime_human+="${mins} minutes"
    else

        # от английского Not Available (Недоступно) или Not Applicable (Не применимо). Он срабатывает в том случае, если скрипту не удалось найти системный файл /proc/uptime.
        uptime_seconds="N/A"
        uptime_human="N/A"
    fi





























# 5. === БЛОК: IP, MASK & GATEWAY ===



    # Сетевая информация
    local main_iface
    # Как узнать, какой сетевой интерфейс (карта) сейчас главный? 
    # Мы «спрашиваем» систему: «Если я захочу отправить пакет по адресу 8.8.8.8 (DNS Google), какой путь ты выберешь?»
    # Команда ip route get имитирует отправку и показывает маршрут.
    # AWK забирает 5-е слово из вывода — это и есть название интерфейса (например, eth0 или wlan0).
    # || echo "eth0" — это «костыль надежности»: если интернет отключен и маршрут не найден, мы просто предположим, что имя карты стандартное.
    main_iface=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $5; exit}' || echo "eth0")

    local machine_ip subnet_mask default_gateway
    # Здесь мы вытягиваем IP-адрес. 
    # ip -4 addr show — показывает только IPv4 адреса для выбранного интерфейса - awk '/inet/' — ищет строку, содержащую "inet" (там лежит адрес).
    # cut -d'/' -f1 — адрес обычно идет в виде 192.168.1.5/24. Эта команда «отрезает» всё, что после слеша, оставляя чистый IP.
    machine_ip=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f1)  
    # По умолчанию cut думает, что колонки разделены символом табуляции. Но в сетевых адресах (например, 192.168.1.5/24) колонки разделены косой чертой /.  Зачем нужна: Она говорит команде: «Считай, что граница между частями строки — это символ, который я укажу следом». В нашем случае -d'/' означает: «Используй / как нож, чтобы разрезать строку».
    # Команда видит -f1: Она берет первый кусок и выбрасывает остальное.

    [[ -z "$machine_ip" ]] && machine_ip="N/A"

    # Флаг -z — (от англ. zero) проверяет, является ли строка пустой (нулевой длины).
    # Если переменная с IP-адресом пустая, то запиши в неё текст "N/A"


    # Расчёт маски из CIDR-префикса (улучшенная версия)
    # CIDR — это то самое число после слеша (например, /24). 
    # Системе проще хранить длину префикса, но человеку привычнее видеть маску типа 255.255.255.0.
    # CIDR — это аббревиатура, которая расшифровывается как Classless Inter-Domain Routing. На русском это звучит как «Бесклассовая адресация» (или буквально: Бесклассовая междоменная маршрутизация).
    local cidr_prefix
    cidr_prefix=$(ip -4 addr show dev "$main_iface" 2>/dev/null | awk '/inet/ {print $2; exit}' | cut -d'/' -f2)
    
    if [[ -n "$cidr_prefix" ]]; then  # Опция -n (Non-zero)
        # Начинается магия AWK. Поскольку Bash не умеет в сложные вычисления, мы передаем задачу сюда.

        # Буква v здесь — сокращение от Variable (переменная). Её главная задача: Передать значение из «мира Bash» внутрь «мира AWK». редставь, что Bash и AWK — это два соседа, которые говорят на разных языках и живут за высоким забором.   Bash — это твой основной скрипт. В нём лежит переменная $cidr_prefix (например, число 24).    AWK — это отдельная программа, которую Bash вызывает для расчетов.AWK не может просто «залезть» в память Bash и взять оттуда переменную. Для него $cidr_prefix — это просто пустой звук. Чтобы AWK узнал это число, нам нужно передать его «через забор». Опция -v как раз и перебрасывает эту переменную.
        
        # Опция -v (variable): Это «мостик» между Bash и AWK. В Bash у нас есть переменная $cidr_prefix (например, число 24). Но внутри AWK свои правила, и он не видит переменные Bash напрямую.
        # Что делает BEGIN? Обычно AWK работает как «читатель»: он открывает файл и выполняет команды для каждой строки, которую найдет. Но что если нам не нужно ничего читать? Что если мы просто хотим использовать AWK как калькулятор? Для этого существует специальный блок BEGIN.    Смысл: Это команда: «Сделай это немедленно, еще до того, как начнешь читать какой-либо файл или входящий текст».    Зачем это здесь: В нашем случае нам не нужно обрабатывать лог-файлы. Нам нужно просто взять число 24 и превратить его в 255.255.255.0. Поэтому мы пишем весь код внутри BEGIN { ... }.    Итог: AWK запускается, делает расчет, печатает результат и тут же закрывается.

        #Весь код AWK, включая BEGIN, обернут в одинарные кавычки: awk '...'. Это сделано не для AWK, а для Bash (основного языка твоего скрипта).  Одинарные кавычки говорят Bash: «Всё, что находится внутри, — это просто текст. Не трогай его, не пытайся его расшифровать, просто передай его программе AWK целиком, как есть».

        subnet_mask=$(awk -v prefix="$cidr_prefix" 'BEGIN {
            # Проверка на дурака: префикс не может быть меньше 0 или больше 32 (бит в IPv4).
            if (prefix == "" || prefix < 0 || prefix > 32) {
                print "N/A";
                exit;
            }
            
            # Расчёт маски через битовые операции:
            # Представьте маску как 32 ячейки, которые заполняются единицами.
            # Если префикс 24, мы ставим 24 единицы в ряд, а остальные 8 забиваем нулями.
            mask = 0;
            for (i = 0; i < prefix; i++) {
                mask = mask * 2 + 1;
            }


1. Пошаговая работа цикла (для prefix = 3)

Изначально переменная mask = 0. Цикл должен выполниться 3 раза.

Шаг 1 (i = 0):

    Берем 0.

    Считаем: 0 * 2 + 1 = 1.

    В двоичном виде это: 1.

Шаг 2 (i = 1):

    Берем 1.

    Считаем: 1 * 2 + 1 = 3.

    В двоичном виде это: 11. (Видишь? Мы просто приставили еще одну единицу справа).

Шаг 3 (i = 2):

    Берем 3.

    Считаем: 3 * 2 + 1 = 7.

    В двоичном виде это: 111.

Результат: мы получили число, которое в двоичной системе состоит из трех единиц. Если префикс будет 24, цикл «нарисует» в памяти компьютера цепочку из 24 единиц.
2. Зачем это нужно для сетевой маски?

Сетевая маска — это всегда ряд единиц, за которым следует ряд нулей.

    Если маска /24, то это 24 единицы и 8 нулей (всего 32 бита).

    Этот цикл выполняет первую часть задачи — формирует цепочку из единиц, соответствующую длине префикса.














            for (i = prefix; i < 32; i++) {
                mask = mask * 2;
            }









# Магия умножения на 2 (без единицы)

# Как мы уже выяснили:

#     mask * 2 + 1 — добавляет в конец единицу.

#     mask * 2 (просто умножение) — сдвигает число влево и добавляет в конец ноль.

# Шаг за шагом (продолжаем пример с /3): После первого цикла у нас было 111 (число 7). Нам нужно «добить» его до 32 бит. Этот цикл начнет работу с i = 3 и пойдет до 32.

#     Шаг (i = 3): 111 превращается в 1110 (число 14).

#     Шаг (i = 4): 1110 превращается в 11100 (число 28). ... и так далее, пока в числе не станет 32 знака.















# Откуда взялись эти странные числа?

#     256 — это 2^8 (вес одного байта).

#     65536 — это 2^16 (вес двух байтов: 256×256).

#     16777216 — это 2^24 (вес трех байтов: 256×256×256).



# Как работает расчет (Разбор «мясорубки»)

#     octet1 = int(mask / 16777216) % 256 Мы делим наше гигантское число на вес трех младших байтов. Это как бы «отбрасывает» три правых октета и сдвигает самый левый октет на первое место. Остаток от деления % 256 гарантирует, что число не выйдет за границы одного байта.

#     octet4 = mask % 256 Это самое простое. Оператор % (остаток от деления) просто отрезает всё лишнее и оставляет только то, что «не влезло» в полные байты — то есть самый правый «хвостик» числа.


            
            # Теперь у нас есть одно огромное число. Чтобы превратить его в привычный вид (X.X.X.X), мы делим его на части (октеты).
            # 16777216, 65536 и 256 — это математические «веса» каждого байта в 32-битном числе.
            octet1 = int(mask / 16777216) % 256;
            octet2 = int(mask / 65536) % 256;
            octet3 = int(mask / 256) % 256;
            octet4 = mask % 256;
            
            # Склеиваем всё точками обратно.
            printf "%d.%d.%d.%d", octet1, octet2, octet3, octet4;

















# После первых двух циклов в нашем скрипте переменная mask превратилась в число, которое в двоичной системе выглядит так: 11100000 00000000 00000000 00000000

# В обычном десятичном виде это огромное число: 3 758 096 384.

# Теперь давай пропустим его через наши формулы:
# 1. Считаем первый октет (octet1)

# octet1 = int(3758096384 / 16777216) % 256

#     Делим: 3758096384/16777216=224 ровно.

#     Берем целое: int(224) — это 224.

#     Остаток: 224%256=224 (так как 224 меньше 256, оно остается собой).

#     Результат: Первый октет маски равен 224.

# 2. Считаем второй октет (octet2)

# octet2 = int(3758096384 / 65536) % 256

#     Делим: 3758096384/65536=57344.

#     Берем целое: 57344.

#     Остаток от 256: 57344/256=224 ровно, остаток 0.

#     Результат: Второй октет равен 0.

# 3. Третий и четвертый октеты

# С ними происходит то же самое:

#     octet3: 3758096384/256=14680064. Делим на 256 — остаток 0.

#     octet4: 3758096384%256=0.

# Итоговый результат:

# Команда printf берет эти цифры и склеивает их: 224.0.0.0
# Почему это работает? (Наглядная схема)

# Представь, что наше огромное число — это 32-битная лента. Числа-делители работают как линейка:

#     16777216 — это начало 4-го байта (самого левого).

#     65536 — начало 3-го байта.

#     256 — начало 2-го байта.

# Когда мы делим на эти числа, мы как бы сдвигаем ленту вправо, чтобы нужный нам кусок оказался в самом начале (в единицах), а потом с помощью % 256 просто «откусываем» этот кусок.

#     Итог: Для маски /3 наш калькулятор выдаст 224.0.0.0. Если бы ты взял привычную маску /24, расчет бы выдал 255.255.255.0. Математика одна и та же!














        }')
    else
        subnet_mask="N/A"
    fi

    # Шлюз по умолчанию (Default Gateway)
    # Это адрес роутера, через который компьютер выходит в большой мир.
    # Мы ищем в таблице маршрутизации строку со словом "default" и берем 3-й столбец.
    default_gateway=$(ip route 2>/dev/null | awk '/default/ {print $3; exit}')
    [[ -z "$default_gateway" ]] && default_gateway="N/A"


    # Разбор конструкции 2>/dev/null (Перенаправление ошибок в «черную дыру»): 
    # 2 — Мы говорим системе: «Смотри именно на канал номер 2 (ошибки)».
    # > — Это символ перенаправления. Он работает как стрелка: «Возьми то, что летит в канал 2, и отправь это в другое место».
    # /dev/null — Это специальный виртуальный файл в Linux, который называют «черной дырой». Всё, что ты в него записываешь, просто исчезает навсегда.



















# 6. === БЛОК 5: RAM_TOTAL, RAM_USED & RAM_FREE ===


    # Цель: Получить данные о памяти в Гб с точностью до 3 знаков после запятой.
    

    # ram_total_gb (Total RAM)    Что это: Весь объем оперативной памяти, который видит твоя операционная система.
    # ram_used_gb (Used RAM)    Что это: Память, которая занята прямо сейчас. Это работающие программы, запущенные скрипты, базы данных и сама система.
    # ram_free_gb (Free RAM)    Что это: Память, которая свободна и готова к использованию. (free — это именно «пустая» память, а не «available», которая включает в себя кэш).

    local ram_total_gb ram_used_gb ram_free_gb

    # Проверка наличия утилиты free. Если её нет (редкость, но бывает в микро-контейнерах),
    # -v: Говорит: «Не запускай команду, просто покажи мне путь к файлу или описание». 
    if command -v free &>/dev/null; then
        
        # 'read -r' — считывает строку и распределяет слова по переменным.
        # Флаг '-r' отключает интерпретацию экранирующих символов (защита данных).
        # Конструкция < <(...) — это Process Substitution (подстановка процесса).
        # ЗАЧЕМ МЫ ЭТО СДЕЛАЛИ: Если использовать обычный конвейер (free | read), команда read выполнится в дочерней оболочке (subshell), и переменные  исчезнут сразу после выхода из неё. Метод < <(...) позволяет сохранить значения переменных в основном процессе скрипта.
        read -r ram_total_gb ram_used_gb ram_free_gb < <(

            # Расшифровка по частям:
                # 1. LC (Locale Category): Первые две буквы расшифровываются как Locale Category (Категория локали). Локаль — это набор настроек, который определяет язык интерфейса, формат даты, времени, денежных знаков и способ сортировки текста в системе.
                # 2. ALL: Указывает, что мы хотим применить настройки ко всем возможным категориям сразу.
                    # (В Linux есть отдельные настройки: LC_TIME для времени, LC_NUMERIC для чисел, LC_MESSAGES для текста ошибок). LC_ALL — это «мастер-ключ», который перекрывает их все.
                # 3.  C (Standard C Locale): Буква «C» здесь — это не просто буква. Это название стандартной системной локали, также известной как POSIX.
                    # Она называется «С» в честь языка программирования C, на котором написан Linux.
                    # Это «родной» язык операционной системы. Он максимально простой, всегда на английском, и в нем нет никаких региональных особенностей (например, в качестве разделителя в числах всегда используется точка, а не запятая).

                # Как это «читает» система?
                # «На время выполнения этой команды забудь, что пользователь живет в России и говорит по-русски. Используй стандартный английский системный формат (C), чтобы вывод был предсказуемым для скрипта».
            
            # ИЗМЕНЕНИЕ №1: LC_ALL=C
            # ПОЧЕМУ: Это принудительная установка стандартной локали (английский язык).
            # На твоем ноутбуке команда 'free' выводит "Память:", а awk ищет "Mem:".
            # Без LC_ALL=C скрипт сломается на любой системе с неанглийским языком.
            # Это делает твой код портабельным и профессиональным.
            
            # ИЗМЕНЕНИЕ №2: free -b
            # ПОЧЕМУ: Опция '-b' выводит данные в байтах. Стандартные '-m' или '-g' выполняют грубое округление на стороне самой утилиты. Чтобы получить точность "хирурга" (3 знака после запятой), мы берем сырые байты  и передаем их для точных вычислений в awk.
            
            LC_ALL=C free -b | awk '/Mem:/ {
                
                # Внутри AWK мы работаем с колонками вывода 'free -b':
                # $2 - total (всего), $3 - used (занято), $4 - free (свободно).
                
                # В Linux 1 Гб = 1024 * 1024 * 1024 байт.
                # Выполняем цепочку делений для перевода единиц измерения.

                total_res = $2 / 1024 / 1024 / 1024;
                used_res  = $3 / 1024 / 1024 / 1024;
                
                # ИЗМЕНЕНИЕ №3: Использование колонки $4 (free_m)
                # ПОЧЕМУ: В предыдущей версии мы использовали $7 (available). 
                # Однако ТЗ Школы 21 требует именно RAM_FREE. 
                # В Linux "Free" — это абсолютно пустая память (колонка $4), 
                # а "Available" — это свободная память плюс кэш. 
                # Чтобы пройти автотесты и строго соблюсти задание, мы берем именно $4.

                free_res  = $4 / 1024 / 1024 / 1024;
                
                # 'printf' формирует итоговую строку. 
                # "%.3f" — спецификатор типа float с 3 знаками после запятой.
                # Числа выводятся через пробел, чтобы команда 'read' выше 
                # смогла разложить их по трем разным "карманам" (переменным).
                printf "%.3f %.3f %.3f", total_res, used_res, free_res
            }'
        )













# В контексте программы `awk`, переменные со знаком доллара и цифрой (**$1, $2, $3...**) — это **номера столбцов (полей)** в строке текста.

# Когда ты передаешь вывод команды `free -b` в `awk`, тот воспринимает каждую строку как таблицу, где столбцы разделены пробелами.

# ### Как `awk` видит твой вывод:

# Давай разберем строку «Память», которую выдала твоя система:

# | $1 (Поле 1)  | $2 (Поле 2)     |   $3 (Поле 3)   |   $4 (Поле 4)     |    $5     |       $6     |      $7     |
# | ------------ | --------------- | --------------- | ----------------- | --------- | ------------ | ----------- |
# | **Память:**  | **16137207808** | **6133673984**  | **4748791808**    | 123330560 | 4034924544   | 10003533824 |
# | *(Название)* | *(Всего/Total)* | *(Занято/Used)* | *(Свободно/Free)* | (Shared)  | (Buff/Cache) | (Available) |

# ### Почему они приобретают эти значения?

# 1. **Поиск строки:** Команда `awk '/Mem:/'` (или в твоем случае с локалью `LC_ALL=C`) ищет строку, в которой есть это слово. Как только `awk` находит нужную строку, он «разрезает» её на куски по пробелам.
# 2. **Присваивание:** * **$1** становится равным названию строки.
# * **$2** забирает число из второго столбца (Total).
# * **$3** забирает число из третьего столбца (Used).
# * **$4** забирает число из четвертого столбца (Free).


# 3. **Автоматическое приведение типов:** Хотя для системы это просто текст, `awk` — умный инструмент. Когда он видит, что ты пытаешься совершить математическое действие (например, `$2 / 1024`), он сам превращает текст `16137207808` в число и считает его.















# В этих строчках происходит **математическое преобразование единиц измерения**: мы переводим огромные числа из «сырых» байтов в человекочитаемые гигабайты.

# Вот подробный разбор того, что делает каждая часть этой формулы:

# ### 1. Что такое $2, $3, $4?

# Это колонки из вывода команды `free -b`. Поскольку мы запустили её с флагом `-b` (bytes), система выдает нам значения в байтах:

# * `$2` (total) — например, `17179869184` байт.
# * `$3` (used) — например, `4294967296` байт.
# * `$4` (free) — например, `2147483648` байт.

# Работать с такими длинными числами неудобно, поэтому мы их конвертируем.

# ---

# ### 2. Почему мы делим на 1024 три раза?

# В компьютерном мире переход между единицами измерения памяти кратен числу **1024** (). Каждое деление поднимает нас на один уровень иерархии выше:

# 1. **Первое деление (`/ 1024`):** Переводит **Байты** в **Килобайты** (Кб).
# 2. **Второе деление (`/ 1024`):** Переводит **Килобайты** в **Мегабайты** (Мб).
# 3. **Третье деление (`/ 1024`):** Переводит **Мегабайты** в **Гигабайты** (Гб).

# > **Математическая справка:** Делить три раза на 1024 — это то же самое, что разделить один раз на  (на **1 073 741 824**).

# ---

# ### 3. Зачем это делать внутри AWK?

# Это критически важный момент для Bash-скриптов:

# * **Ограничение Bash:** Стандартный интерпретатор Bash умеет работать **только с целыми числами**. Если ты попробуешь разделить `5 / 2`, Bash выдаст `2`, просто отбросив всё после запятой.
# * **Сила AWK:** Утилита `awk` — это полноценный язык программирования, который поддерживает числа с плавающей точкой (дробные числа).

# Именно благодаря `awk` мы можем получить не просто «15 Гб», а точный результат «15.029 Гб», как того требует задание Школы 21.

# ---

# ### Итоговый смысл каждой строки:

# * `total = $2 / 1024 / 1024 / 1024;`
# * *«Возьми общее количество байтов и узнай, сколько это целых и дробных гигабайтов».*


# * `used = $3 / 1024 / 1024 / 1024;`
# * *«Узнай, сколько Гб памяти сейчас реально занято процессами».*


# * `free_m = $4 / 1024 / 1024 / 1024;`
# * *«Узнай, сколько Гб памяти простаивает абсолютно впустую».*



# Затем эти результаты попадают в `printf "%.3f"`, который просто обрезает «хвост» числа, оставляя ровно три знака после точки.

    else
        # Если утилита 'free' не установлена (например, в минимальном Docker-образе),
        # мы присваиваем переменным значение "N/A" (Not Available).
        # Это предотвращает пустые строки в отчете и делает вывод предсказуемым.
        ram_total_gb="N/A"
        ram_used_gb="N/A"
        ram_free_gb="N/A"
    fi




























































# 7. === БЛОК 6: SPACE_ROOT, SPACE_ROOT_USED & SPACE_ROOT_FREE ===


# В контексте Linux и твоего задания, рутовый раздел (от англ. root — корень) — это главный раздел твоего жесткого диска или SSD, на котором установлена сама операционная система.

# Информация о диске
# Root Space	df	Физический накопитель (SSD/HDD). Данные хранятся постоянно, даже при выключении питания.
# Цель: Получить данные о дисковом пространстве корневого раздела (/) в Мб с точностью до 2 знаков после запятой.

    local root_total_mb root_used_mb root_free_mb
    
    # Проверка наличия утилиты df (Disk Free).
    if command -v df &>/dev/null; then
        
        # Конструкция < <(...) — «Подстановка процесса» (Process Substitution). она заставляет вывод команды выглядеть для системы как временный файл.
        # 1. Как это расшифровывается? Эта конструкция состоит из двух разных операторов, которые пишутся вместе:
            # <( ... ) (Внутренняя часть): Запускает команду внутри скобок и создает в оперативной памяти «трубу» (named pipe), которая для системы выглядит как файл по адресу /dev/fd/63 (номер может меняться).
            # < (Внешний левый знак): Это обычный оператор перенаправления ввода. Он говорит команде read: «Возьми данные не из клавиатуры, а из файла, который стоит справа».
            # Итог: Команда read думает, что читает данные из обычного текстового файла, хотя на самом деле она читает их напрямую из вывода awk.
        
        # Это подстановка процесса. Мы используем её вместе с командой read, чтобы избежать создания дочерней оболочки (subshell), которую порождает обычный конвейер. Это позволяет сохранить значения переменных в основном теле скрипта


        # Почему нельзя просто написать: df | awk | read ... ?
        # Потому что в Bash пайп (|) создает дочерний процесс. Переменные, заполненные внутри пайпа, умирают вместе с ним и не попадают в основной скрипт.
        # < <(...) создает временный «файл-призрак» (дескриптор), который команда read может прочитать, оставаясь в текущем процессе. Так переменные сохраняются.
        
        read -r root_total_mb root_used_mb root_free_mb < <(
            
            # df -B1 /
            # Мы проверяем корень системы (/). В Linux / — это не просто "корень", это точка монтирования (mount point). какое  устройство хранения  (например, /dev/nvme0n1p2 или /dev/sda3) привязано к этой точке. Если ты просто напишешь df, команда выведет список всех примонтированных файловых систем (включая временные tmpfs, петлевые loop от snap-пакетов и сетевые диски). Указание / жестко ограничивает выборку только одной конкретной файловой системой, в которой живет вся твоя ОС. Например /dev/nvme0n1p5 после команды - df  / 

            # Опция -B1 (Block size = 1 byte) заставляет df выводить размеры строго в байтах.
            # Зачем? Если использовать df -h (human readable), он выдаст "20G".
            # С текстом "20G" математику не сделаешь, нам нужны «голые» цифры для точности.
            # 2>/dev/null — глушим ошибки, если вдруг прав нет (хотя на df они обычно есть).
            # awk 'NR==2' — (Number of Record) ВЫВЕСТИ ТОЛЬКО 2-Ю СТРОКУ ВЫВОДА БЕЗ НАЗВАНИЯ СТОЛБЦОВ
            
            df -B1 / 2>/dev/null | awk 'NR==2 {
                
                # Вывод команды df всегда состоит из двух строк:
                # Строка 1: Заголовки (Filesystem 1B-blocks Used Available...)
                # Строка 2: Сами цифры.
                # Мы говорим AWK: «Игнорируй первую строку, начинай работать только когда номер строки (NR) равен 2».
                
                # Математика:
                # Мы получили байты, а хотим мегабайты (MB).
                # Делим на 1024 (получаем КБ), потом еще раз на 1024 (получаем МБ).
                total = $2/1024/1024;
                used = $3/1024/1024;
                free = $4/1024/1024;
                
                # Форматируем: %.2f оставляет 2 знака после запятой.
                printf "%.2f %.2f %.2f", total, used, free
            }'
        )
    else
        # Заглушка на случай, если df нет (например, в микро-контейнере)
        root_total_mb="N/A"
        root_used_mb="N/A"
        root_free_mb="N/A"
    fi
























# 8. === БЛОК: ФОРМИРОВАНИЕ ИТОГОВОГО ОТЧЕТА ===


    # cat <<EOF — Это конструкция под названием "Here Document" (Heredoc).
    # Простыми словами: это способ сказать Bash: «Сейчас я вывалю на тебя целую кучу текста, просто печатай всё подряд, пока не встретишь слово EOF (End Of File)».
    
    # Почему это круто? Тебе не нужно писать команду echo перед каждой строчкой. 
    # Ты просто рисуешь шаблон будущего отчета прямо в коде, и Bash сам подставит значения переменных в нужные места.
    
    cat <<EOF
HOSTNAME = $node_name
TIMEZONE = $tz_name UTC $tz_offset
USER = $active_user
OS = $os_release
DATE = $current_moment
UPTIME = $uptime_human
UPTIME_SEC = ${uptime_seconds} seconds
IP = $machine_ip
MASK = $subnet_mask
GATEWAY = $default_gateway
RAM_TOTAL = ${ram_total_gb} GB
RAM_USED = ${ram_used_gb} GB
RAM_FREE = ${ram_free_gb} GB
SPACE_ROOT = ${root_total_mb} MB
SPACE_ROOT_USED = ${root_used_mb} MB
SPACE_ROOT_FREE = ${root_free_mb} MB
EOF
    # EOF — это «стоп-сигнал». Когда Bash видит это слово в начале строки, 
    # он понимает: «Ага, многострочный ввод закончен, закрываем поток».
}





























# 9. === БЛОК: ИНТЕРАКТИВНОЕ СОХРАНЕНИЕ В ФАЙЛ ===




# # Разбор строки: local facts_snapshot="$1"
# Текст не берется из ниоткуда. Он проходит путь от **создания** до **приема**.

# ### 1. Как данные попадают в $1? (Внешняя связь)

# В Bash `$1` — это **первый аргумент**, который передали функции при её вызове.

# Посмотри в самый низ своего скрипта, в функцию `main`. Там есть две ключевые строчки:

# ```bash
# # 1. Мы запускаем сбор данных и сохраняем ВЕСЬ текст в переменную system_report
# system_report=$(gather_system_facts)

# # 2. Мы вызываем функцию сохранения и ПЕРЕДАЕМ ей этот текст в качестве "посылки"
# prompt_persistence "$system_report"

# ```

# В тот момент, когда ты написал `prompt_persistence "$system_report"`, всё содержимое твоего отчета (от HOSTNAME до SPACE_ROOT) упаковалось и «полетело» внутрь функции.

# ---

# ### 2. Что делает `local facts_snapshot="$1"`? (Внутренняя работа)

# Когда выполнение прыгает внутрь функции `prompt_persistence`, Bash автоматически присваивает прилетевшую «посылку» технической переменной `$1`.

# Но работать с переменной, которая называется просто «цифра 1» — неудобно и легко запутаться. Поэтому первой же строчкой мы делаем **переименование**:

# * **`local`**: Мы говорим: «Эта переменная будет существовать только внутри этой функции. Как только функция закончит работу, память очистится». Это защищает скрипт от ошибок.
# * **`facts_snapshot`**: Это новое, понятное имя для нашей «посылки». Мы назвали её «снимок фактов».
# * **`="$1"`**: Мы копируем содержимое технической переменной `$1` в нашу новую переменную.

# ---

# ### 3. Зачем это нужно дальше в коде?

# Теперь, когда у нас есть переменная `facts_snapshot`, мы можем использовать её внутри цикла `while`, когда спрашиваем пользователя: «Сохранить в файл?».

# Посмотри на блок `case` в твоем коде:

# ```bash
# case "$user_choice" in
#     y|yes)
#         # ... создание имени файла ...
#         if echo "$facts_snapshot" > "$report_name"; then
#             echo "Отчёт сохранён"
#         fi

# ```

# **Если бы мы не написали `local facts_snapshot="$1"`:**
# Нам пришлось бы писать `echo "$1" > "$report_name"`. Это работало бы точно так же, но читать такой код через месяц было бы очень сложно — непонятно, что именно лежит в этой «единице».

# ---

# ### Итог: Связующее звено

# 1. **Функция `gather_system_facts**` — генерирует текст.
# 2. **Переменная `system_report**` — временно хранит этот текст в главной части скрипта (`main`).
# 3. **Вызов `prompt_persistence "$system_report"**` — отправляет текст в функцию.
# 4. **Строка `local facts_snapshot="$1"**` — ловит этот текст на входе в функцию и дает ему красивое имя, чтобы потом записать его в файл через `echo`.

# **Простыми словами:** Эта строчка — это **«приемник»**. Она ловит данные, которые ты отправил в функцию из другого места скрипта.








# local facts_snapshot="$1" - А КАК ТАК ПОЛУЧАЕТСЯ ЧТО ДАННЫЕ ПЕРЕДАЮТСЯ В ЭТУ ПЕРЕМЕННУЮ ? 


# Весь секрет в том, что в Linux **функции работают как маленькие самостоятельные программки внутри твоего скрипта.**

# Чтобы данные попали в `facts_snapshot`, они проходят три этапа: **Упаковка**, **Бросок** и **Захват**.

# ---

# ### 1. Упаковка (в главной части скрипта)

# Сначала ты создаешь «посылку». Когда ты пишешь:
# `system_report=$(gather_system_facts)`
# Ты говоришь системе: «Запусти сбор данных, поймай всё, что он напечатает, и засунь это в коробку с надписью `system_report`».

# ### 2. Бросок (вызов функции)

# Теперь тебе нужно передать эту коробку в другую функцию. Ты пишешь:
# `prompt_persistence "$system_report"`

# **Вот здесь происходит магия:**
# Когда Bash видит пробел после названия функции, он понимает, что всё, что идет дальше — это **аргументы** (входящие данные).

# * Он берет содержимое `system_report` и «бросает» его внутрь функции `prompt_persistence`.

# ### 3. Захват (внутри функции) — это и есть твоя строка

# Как только выполнение кода прыгает внутрь `prompt_persistence`, Bash автоматически и без твоего участия раскладывает все «прилетевшие» данные по стандартным ячейкам-номерам:

# * Первый аргумент попадает в переменную **`$1`**
# * Второй (если бы был) в **`$2`**
# * И так далее.

# **И вот тут срабатывает твоя строчка:**
# `local facts_snapshot="$1"`

# 1. **`$1`** — это та самая «техническая ячейка», куда Bash только что положил твой отчет.
# 2. **`facts_snapshot`** — это твоя «именная корзина».
# 3. **`=`** — это команда «переложи содержимое из технической ячейки в мою корзину».
# 4. **`local`** — это уточнение: «эта корзина стоит только в этой комнате (функции), в другие комнаты её не носи».

# ---

# ### Почему нельзя было сразу написать `facts_snapshot`?

# Потому что функция — это «черный ящик». Она не знает, как назывались переменные **снаружи**.

# * Снаружи это мог быть `system_report`.
# * Или `old_data`.
# * Или вообще просто текст в кавычках `"Привет"`.

# Функции всё равно, как это называлось раньше. Она знает только одно: **«Мне что-то прислали, и это что-то лежит в ячейке №1»**.

# ### Наглядная аналогия:

# Представь **почтомат**:

# 1. Ты (главный скрипт) кладешь посылку в **ячейку №1** и закрываешь её.
# 2. Курьер (функция `prompt_persistence`) приходит к почтомату.
# 3. Он не знает, как ты называл эту посылку дома («Старый свитер» или «Подарок»).
# 4. Он просто открывает **ячейку №1** (`$1`) и перекладывает содержимое в свой рюкзак, на котором написано **`facts_snapshot`**.

# **Теперь курьер может ходить с этим рюкзаком по всей функции и использовать данные.**

# Теперь картинка сложилась? Ты буквально «переливаешь» данные из безымянной системной переменной `$1` в свою собственную переменную с понятным именем.






# 9. === БЛОК: ИНТЕРАКТИВНОЕ СОХРАНЕНИЕ В ФАЙЛ ===




prompt_persistence() {
    # local facts_snapshot="$1"
    # Мы принимаем внутрь функции все собранные данные (весь тот текст из cat <<EOF).
    # Теперь они хранятся в переменной facts_snapshot.
    local facts_snapshot="$1"
    
    # while true; do — Это «бесконечный цикл». 
    # Скрипт будет крутиться здесь до тех пор, пока не получит четкий ответ (Да или Нет).
    # Это защита от того, чтобы пользователь не ввел случайную абракадабру.
    while true; do
        # read -rp — Команда для диалога.
        # -r: защита от спецсимволов.
        # -p (prompt): позволяет написать текст вопроса прямо в команде, не используя echo.
        read -rp "Сохранить результат в файл? (Y/N): " user_choice
        
        # user_choice=$(echo ... | tr '[:upper:]' '[:lower:]')
        # Это «уравниватель шансов». Команда tr (translate) превращает все БОЛЬШИЕ буквы в маленькие.
        # Зачем: чтобы скрипту было всё равно, нажал ли пользователь "Y" или "y". 
        # Мы приводим любой ввод к нижнему регистру для легкого сравнения.
        user_choice=$(echo "$user_choice" | tr '[:upper:]' '[:lower:]')
        
        # case — Это «разветвитель». Он проверяет, на какой из вариантов похож ввод пользователя.
        case "$user_choice" in
            # Если ввели y или yes:
            y|yes)
                local timestamp report_name
                # 1. Переменная timestamp (Временная метка). Что в ней хранится: Текущее время в виде строки цифр, разделенных нижним подчеркиванием. Пример значения: 04_01_26_04_30_15
                # 2. Переменная report_name (Имя отчета). Что в ней хранится: Полное имя файла для сохранения, состоящее из временной метки и расширения .status. Пример значения: 04_01_26_04_30_15.status
                
                # Создаем уникальное имя для файла.
                # date +"%d_%m_%y_%H_%M_%S" — берет текущую дату и время до секунды.
                # Получится что-то вроде: 30_12_25_15_30_05.status
                # Так файлы никогда не перезапишут друг друга.
                timestamp=$(date +"%d_%m_%y_%H_%M_%S")
                report_name="${timestamp}.status"
                
                # Проверка успешности создания файла.
                # Мы пытаемся «выстрелить» текстом отчета в файл через знак >.
                # if ... 2>/dev/null — если диск переполнен или нет прав на запись, ошибка уйдет в «черную дыру», а сработает блок else.
                if echo "$facts_snapshot" > "$report_name" 2>/dev/null; then
                    echo -e "\nОтчёт сохранён: $report_name"
                    return 0 # Выходим из функции с успехом.
                else
                    echo -e "\nОшибка: не удалось сохранить файл в текущей директории" >&2
                    return 1 # Выходим с кодом ошибки.
                fi
                ;;
            # Если ввели n или no:
            n|no)
                echo -e "\nДанные не будут сохранены."
                return 0 # Просто выходим из цикла.
                ;;
            # Если ввели что-то непонятное (любой другой символ — *):
            *)
                echo "Некорректный ввод. Используйте Y или N."
                # Цикл while не прерывается, и вопрос задается снова.
                ;;
        esac
    done
}




















# === 10. БЛОК: ГЛАВНАЯ ФУНКЦИЯ ===


# Точка входа (Entry Point)
# Мы упаковываем основную логику в функцию main, чтобы скрипт был структурированным и предсказуемым.
main() {
    
    # 1. Проверка зависимостей
    # Первым делом вызываем функцию check_dependencies. 
    check_dependencies
    
    # 2. Сбор урожая данных
    # Создаем локальную переменную system_report.
    # system_report=$(gather_system_facts) — запускает ту самую огромную функцию сбора данных.
    # Весь текст, который выдал cat <<EOF внутри gather_system_facts, теперь «законсервирован»  внутри этой переменной. 
    local system_report 
    system_report=$(gather_system_facts)
    
    # 3. Вывод на сцену
    # Печатаем красивую шапку. Опция -e позволяет добавить \n (перенос строки) для отступа.
    echo -e "\n=== СИСТЕМНАЯ СВОДКА ==="
    
    # Выводим содержимое нашей переменной-отчета.
    echo "$system_report"
    echo "======================="
    
    # 4. Сохранение (по желанию пользователя)
    # Передаем наш готовый отчет ($system_report) в функцию prompt_persistence.
    # Там скрипт спросит: «Ну что, сохраняем в файл?» и, если нужно, запишет его на диск.
    prompt_persistence "$system_report"
}

# Магическая строка запуска
# main "$@" — это команда, которая фактически дает старт всему скрипту.
# "$@" — это специальная переменная Bash, которая передает внутрь функции main 
# все аргументы, которые ты мог написать при запуске (например: ./script.sh arg1 arg2).
# Даже если аргументов нет, это «золотой стандарт» написания скриптов.
main "$@"