#!/usr/bin/env bash

set -euo pipefail

# set в Bash — это «пульт управления» настройками самого интерпретатора. Она меняет поведение оболочки: определяет, как скрипт должен реагировать на ошибки, пустые переменные или выполнение команд.

# set -e → включить errexit (выход при ошибке),
# set -u — запрет использования неопределённых переменных
# set -o означает: «включи/выключи именованную опцию».
# set -o pipefail → включить режим, при котором пайплайн завершается с ошибкой, если любая команда в нём упала.
# Опции вроде pipefail, nounset, errexit, errtrace — это длинные (именованные) опции, и их можно включить только через -o имя_опции.
# pipefail — аргумент для -o. Когда включена опция pipefail:  Пайплайн завершается с ошибкой, если ЛЮБАЯ команда в нём вернула ошибку (если только все команды не успешны — тогда 0).


# Если коротко: set -e следит за одиночными командами, а set -o pipefail следит за цепочками команд (пайпами).

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"


# Что такое BASH_SOURCE[0] на самом деле? Это массив. Его нулевой элемент ([0]) всегда содержит путь к текущему файлу скрипта.

# Команда dirname (от английского directory name) — это стандартная утилита в Linux/Unix, которая выполняет одну простую задачу: она отрезает имя файла от пути, оставляя только путь к папке (директории), в которой этот файл находится.

# Когда ты запускаешь скрипт именно командой `./echo_spell.sh Привет`, находясь **в той же папке**, где лежат файлы, вот что происходит пошагово внутри этой «магической» строки:

# ### 1. Переменная `${BASH_SOURCE[0]}`

# Bash видит, как именно ты вызвал скрипт. Раз ты написал `./echo_spell.sh`, то внутри переменной будет:

# * **Значение:** `./echo_spell.sh`

# ### 2. Команда `dirname`

# Она берет строку `./echo_spell.sh` и отрезает имя файла. Остается только путь к папке:

# * **Результат:** `.` (точка в Linux означает «текущая папка»)

# ### 3. Команда `cd "."`

# Теперь выполняется команда перехода в эту папку. Поскольку точка — это «здесь же», Bash просто подтверждает свое местоположение.

# ### 4. Команда `pwd`

# Это ключевой момент. Команда `pwd` (Print Working Directory) игнорирует относительные пути (точки) и выдает **полный «физический» адрес** от корня диска.

# * Например, если твоя папка на самом деле лежит в документах, `pwd` вернет:
# `/home/user/projects/magic_script`

# ### 5. Присваивание `SCRIPT_DIR`

# Весь этот вычисленный длинный путь записывается в переменную. Теперь переменная `SCRIPT_DIR` равна не просто точке `.`, а полноценному адресу: `/home/user/projects/magic_script`.

# ---

# ### Почему это сработало в твоем случае?

# Когда дальше по коду идет строка:
# `source "$SCRIPT_DIR/whisper_validator.sh"`

# Bash превращает её в:
# `source "/home/user/projects/magic_script/whisper_validator.sh"`

# **В чем магия:**
# Даже если ты выйдешь из этой папки (например, напишешь `cd ..`) и попробуешь запустить скрипт издалека:
# `./magic_script/echo_spell.sh Привет`

# Скрипт **все равно найдет** файл валидатора, потому что `SCRIPT_DIR` вычислит правильный путь `/home/user/projects/magic_script`, а не будет искать его в твоей текущей папке.

# ---

# **Что дальше?**
# Теперь, когда `SCRIPT_DIR` определен, скрипт переходит к выполнению `validate_whisper "$@"`. Хочешь разберем, как именно символ `"$@"` передает твое слово "Привет" внутрь функции валидации?


source "$SCRIPT_DIR/whisper_validator.sh"

#Команда source (в Bash её также можно заменить простым символом точки .) — это команда, которая заставляет текущую оболочку (shell) прочитать указанный файл и выполнить содержащийся в нем код внутри текущего процесса.

# Главный скрипт «импортирует» функцию validate_whisper.

# Сначала Bash берет переменную $SCRIPT_DIR, которую мы вычислили строчкой выше (например, /home/s/.../P1), и подставляет её в строку. Команда превращается из: source "$SCRIPT_DIR/whisper_validator.sh" в: source "/home/s/Рабочий стол/.../P1/whisper_validator.sh"


# Проверка количества аргументов
if [[ $# -ne 1 ]]; then # Если количество аргументов НЕ равно 1...
    echo "error: требуется ровно одно заклинание." >&2   # Перенаправление в поток ошибок >&2
    exit 1
fi

# $# — это специальная встроенная переменная в Bash, которая работает как счётчик. Она показывает, сколько аргументов (слов) ты передал скрипту при его запуске.

# Запуск с одним словом: ./echo_spell.sh Привет В этом случае $# = 1 (Аргумент $1 — это "Привет")

# Валидация содержимого
validate_whisper "$1" || exit 1

# 1. validate_whispe. Это та самая функция, которую ты «импортировал» из файла whisper_validator.sh с помощью команды source. Теперь она работает как обычная команда Bash.
# Если ты запустил ./echo_spell.sh Привет, то в "$1" подставится слово Привет.
# Кавычки здесь критически важны: они защищают строку, если в ней вдруг окажутся пробелы или спецсимволы.

# Эта команда выполняется только в том случае, если валидация провалилась. Она мгновенно завершает работу всего скрипта с кодом ошибки 1.

echo "$1" # выводит на экран то самое «заклинание» (первый аргумент), которое ты передал при запуске.
